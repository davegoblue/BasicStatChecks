<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Synopsis and Overview</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<h1>Synopsis and Overview</h1>

<p>This document contains some of the key concepts, statistics, and R formulae from the UvA Inferential Statistics course.  It is intended as a helpful reference sheet for future use.  </p>

<h2>Module 1: Comparing Two Groups</h2>

<p>There are two schools of thought, frequentist (more common) and Bayesian (growing):  </p>

<ul>
<li>Frequentist - what are the odds of observing X given my hypothesized population?<br/></li>
<li>Bayesian - what are the odds of a hypothesized population given that I observed X?<br/></li>
</ul>

<p>There are a few good cautions raised about significance and confidence levels:  </p>

<ul>
<li>Statistical Significance - The x% confidence interval is constructed such that if we run the experiment infinite times, x% of our intervals would contain the true population mean<br/></li>
<li>Practical Significance - does it actually matter that Ho: P=0 is rejected?  The confidence interval helps to assess effect magnitude<br/></li>
</ul>

<p>Recall that there are two key error types:  </p>

<ul>
<li>Type I (reject a true null) - happens (1 - alpha), where alpha is pre-set<br/></li>
<li>Type II (fail to reject a false null) &ndash; happend beta, so (1 - beta) is the test power<br/></li>
<li>Power is increased by better instruments, more homogenous samples, larger N, larger effect, one-sided tests, parametric tests (for sufficiently large N)<br/></li>
</ul>

<p>####<em>Two indepedent proportions</em><br/>
The main metric is a z-test, and it generally requires at least 10 positive and 10 negative per group for one-sided tests, and at least 5 positive and 5 negative per group for two-sided tests:  </p>

<p>The test statistic is designed to follow a z-distribution, specifically:  </p>

<ul>
<li>Since null is equality, the test stastic starts as (p1-hat - p2-hat)<br/></li>
<li>Standard error is then sqrt(p-hat * (1 - p-hat) * (1/n1 + 1/n2))<br/></li>
<li>P-hat is the pooled proportion, or (n1 * p1-hat + n2 * p2-hat) / (n1 + n2)<br/></li>
<li>CI (after the fact) can no longer use the pooled proportion since null is no longer assumed<br/></li>
<li>(p1-hat - p2-hat) +/- z(alpha/2) * sqrt(p-hat1 * (1-p-hat1) / n1 + p-hat2 * (1-p-hat2) / n2)<br/></li>
</ul>

<p>This can also be expressed as a relative risk, or p1/p2, with its own assumed confidence intervals.  </p>

<p>See below for an example from two random normal distributions:  </p>

<pre><code class="r">set.seed(0313160758)
norm1 &lt;- rnorm(100,mean=2,sd=1)
norm2 &lt;- rnorm(120,mean=2.5,sd=1.5)
p1Norm &lt;- norm1 &gt; 2
p2Norm &lt;- norm2 &gt; 2
p1Hat &lt;- mean(p1Norm)
p2Hat &lt;- mean(p2Norm)
n1 &lt;- length(p1Norm)
n2 &lt;- length(p2Norm)

## Calculate means, difference, pooled proportion, standard error
print(paste0(&quot;Means of the data are P1: &quot;,p1Hat,&quot; and P2: &quot;,p2Hat))
</code></pre>

<pre><code>## [1] &quot;Means of the data are P1: 0.6 and P2: 0.55&quot;
</code></pre>

<pre><code class="r">poolProp &lt;- (n1*p1Hat + n2*p2Hat) / (n1 + n2)
stdError &lt;- sqrt(poolProp * (1-poolProp) * (1/n1 + 1/n2))
print(paste0(&quot;Pooled proportion is: &quot;,round(poolProp,3),&quot; with stderr: &quot;,round(stdError,3)))
</code></pre>

<pre><code>## [1] &quot;Pooled proportion is: 0.573 with stderr: 0.067&quot;
</code></pre>

<pre><code class="r">## Calculate test statistic and p-value
zTestStat &lt;- (p1Hat - p2Hat) / stdError
pTwoSided &lt;- 1 - 2 * abs((pnorm(zTestStat) - 0.5))
print(paste0(&quot;The z-stat of: &quot;,round(zTestStat,3),&quot; which has z^2: &quot;,round(zTestStat^2,3),
             &quot; has two-sided significance: &quot;,round(pTwoSided,3)
             )
      )
</code></pre>

<pre><code>## [1] &quot;The z-stat of: 0.746 which has z^2: 0.557 has two-sided significance: 0.455&quot;
</code></pre>

<pre><code class="r">## Calculate post-hoc CI
newStdErr &lt;- sqrt(p1Hat * (1 - p1Hat) / n1 + p2Hat * (1 - p2Hat) / n2)
critZ &lt;- qnorm(.05/2, lower.tail=FALSE)
print(paste0(&quot;Post-hoc 95% CI for difference in proportions is &quot;,
             paste(round(p1Hat - p2Hat + c(-1,1) * critZ * newStdErr, 3), collapse=&quot; , &quot;)
             )
      )
</code></pre>

<pre><code>## [1] &quot;Post-hoc 95% CI for difference in proportions is -0.081 , 0.181&quot;
</code></pre>

<pre><code class="r">## Comparison to R -- note that R uses chi-squared which is directly related to N(0.1)
prop.test(x=c(sum(p1Norm),sum(p2Norm)) , n=c(n1, n2) , correct=FALSE)
</code></pre>

<pre><code>## 
##  2-sample test for equality of proportions without continuity
##  correction
## 
## data:  c(sum(p1Norm), sum(p2Norm)) out of c(n1, n2)
## X-squared = 0.55724, df = 1, p-value = 0.4554
## alternative hypothesis: two.sided
## 95 percent confidence interval:
##  -0.08092941  0.18092941
## sample estimates:
## prop 1 prop 2 
##   0.60   0.55
</code></pre>

<p>And, we observe that the findings from R match the hand calculations, with the exception that R runs a chi-squared test and the hand calculations are a z-test.  If x~N(0,1) then x<sup>2</sup> ~ chi-squared df=1, so these are functionally the same approach and outcome.  </p>

<p>####<em>Two indepedent means</em><br/>
For two indepednent means, the t-test is applied.  This requires independence of samples, roughly normal population distributions (though t is robust against this), and a &ldquo;large enough&rdquo; (N ~30) sample:  </p>

<p>The test statistic is designed to follow a t-distribution, specifically:  </p>

<p>#####<em>Unequal variance</em>  </p>

<ul>
<li>Since null is equality, the test stastic starts as (x1-hat - x2-hat)<br/></li>
<li>Pooled standard error is then unPSE = sqrt(s1<sup>2/n1</sup> + s2<sup>2/n2)</sup><br/></li>
<li>df is a cluster - (s1<sup>2/n1</sup> + s2<sup>2/n2)<sup>2</sup></sup> / [ (s1<sup>2/n1)<sup>2</sup></sup> / (n1 - 1) + (s2<sup>2/n2)<sup>2</sup></sup> / (n2 - 1) ]<br/></li>
<li>Test-statistic is (x1-hat - x2-hat) / unPSE, following t with df<br/></li>
<li>Post-hoc CI is (x1-bar - x2-bar) +/- t(alpha/2) * unPSE </li>
</ul>

<p>#####<em>Assume equal variance</em>  </p>

<ul>
<li>Pooled standard error is then eqPSE = sqrt( [ (n1-1) * s1<sup>2</sup> + (n2-1) * s2<sup>2</sup> ] / [ (n1 - 1) + (n2 - 1) ]<br/></li>
<li>df is easy - n1 + n2 - 2<br/></li>
<li>Test-statistic is (x1-hat - x2-hat) / eqPSE, following t with df<br/></li>
</ul>

<p>Note that the unequal variances approach is greatly preferred, as the equal variances approach can be sensitive to violations of normality.  </p>

<p>See below for an example from two random normal distributions (we will keep the norm1 and norm2 as originally drawn, but without any conversions for &ldquo;greater than 2&rdquo;:  </p>

<pre><code class="r">x1Hat &lt;- mean(norm1)
x2Hat &lt;- mean(norm2)
s1 &lt;- sd(norm1)
s2 &lt;- sd(norm2)
n1 &lt;- length(p1Norm)
n2 &lt;- length(p2Norm)

## Report on individual means, standard deviations, and sample sizes
print(paste0(&quot;Distribution 1 has mean: &quot;,round(x1Hat,2),&quot; with std &quot;,round(s1,2),&quot; on n=&quot;,n1))
</code></pre>

<pre><code>## [1] &quot;Distribution 1 has mean: 2.19 with std 1.09 on n=100&quot;
</code></pre>

<pre><code class="r">print(paste0(&quot;Distribution 2 has mean: &quot;,round(x2Hat,2),&quot; with std &quot;,round(s2,2),&quot; on n=&quot;,n2))
</code></pre>

<pre><code>## [1] &quot;Distribution 2 has mean: 2.44 with std 1.59 on n=120&quot;
</code></pre>

<pre><code class="r">## Run this as an unequal variance approach
unPSE &lt;- sqrt(s1^2/n1 + s2^2/n2)
unDF &lt;- (s1^2/n1 + s2^2/n2)^2 / ((s1^2/n1)^2 / (n1-1) + (s2^2/n2)^2 / (n2-1))
print(paste0(&quot;Assuming unequal variance, we have difference: &quot;,round(x1Hat - x2Hat,2),
             &quot; with pooled SE: &quot;,round(unPSE,2),&quot; and df = &quot;,round(unDF,1)
             )
      )
</code></pre>

<pre><code>## [1] &quot;Assuming unequal variance, we have difference: -0.26 with pooled SE: 0.18 and df = 210.3&quot;
</code></pre>

<pre><code class="r">unTest &lt;- (x1Hat - x2Hat) / unPSE
unPTwoSided &lt;- 1 - 2 * abs(pt(unTest,df=unDF) - 0.5)
print(paste0(&quot;The t-statistic &quot;,round(unTest,3),&quot; has two-sided significance &quot;,round(unPTwoSided,3)))
</code></pre>

<pre><code>## [1] &quot;The t-statistic -1.416 has two-sided significance 0.158&quot;
</code></pre>

<pre><code class="r">critT &lt;- qt(.05/2,df=unDF,lower.tail=FALSE)
print(paste0(&quot;The 95% CI for difference in means is &quot;,
             paste(round(x1Hat - x2Hat + c(-1,1) * critT * unPSE, 3), collapse=&quot; , &quot;)
             )
      )
</code></pre>

<pre><code>## [1] &quot;The 95% CI for difference in means is -0.615 , 0.101&quot;
</code></pre>

<pre><code class="r">## Comparison to the R results
t.test(norm1,norm2,paired=FALSE,var.equal=FALSE)
</code></pre>

<pre><code>## 
##  Welch Two Sample t-test
## 
## data:  norm1 and norm2
## t = -1.4156, df = 210.29, p-value = 0.1584
## alternative hypothesis: true difference in means is not equal to 0
## 95 percent confidence interval:
##  -0.6149437  0.1009042
## sample estimates:
## mean of x mean of y 
##  2.187555  2.444575
</code></pre>

<pre><code class="r">## Run this as an equal variance approach
eqS &lt;- sqrt( ( (n1-1) * s1^2 + (n2-1) * s2^2 ) / ( (n1 - 1) + (n2 - 1) ) )
eqPSE &lt;- eqS * sqrt(1/n1 + 1/n2)
eqDF &lt;- n1 + n2 - 2
print(paste0(&quot;Assuming equal variance, we have difference: &quot;,round(x1Hat - x2Hat,2),
             &quot; with S: &quot;,round(eqS,2),&quot; and pooled SE: &quot;,round(eqPSE,2),&quot; with df = &quot;,round(eqDF,1)
             )
      )
</code></pre>

<pre><code>## [1] &quot;Assuming equal variance, we have difference: -0.26 with S: 1.39 and pooled SE: 0.19 with df = 218&quot;
</code></pre>

<pre><code class="r">eqTest &lt;- (x1Hat - x2Hat) / eqPSE
eqPTwoSided &lt;- 1 - 2 * abs(pt(eqTest,df=eqDF) - 0.5)
print(paste0(&quot;The t-statistic &quot;,round(eqTest,3),&quot; has two-sided significance &quot;,round(eqPTwoSided,3)))
</code></pre>

<pre><code>## [1] &quot;The t-statistic -1.369 has two-sided significance 0.172&quot;
</code></pre>

<pre><code class="r">critT &lt;- qt(.05/2,df=eqDF,lower.tail=FALSE)
print(paste0(&quot;The 95% CI for difference in means is &quot;,
             paste(round(x1Hat - x2Hat + c(-1,1) * critT * eqPSE, 3), collapse=&quot; , &quot;)
             )
      )
</code></pre>

<pre><code>## [1] &quot;The 95% CI for difference in means is -0.627 , 0.113&quot;
</code></pre>

<pre><code class="r">## Comparison to the R results
t.test(norm1,norm2,paired=FALSE,var.equal=TRUE)
</code></pre>

<pre><code>## 
##  Two Sample t-test
## 
## data:  norm1 and norm2
## t = -1.3693, df = 218, p-value = 0.1723
## alternative hypothesis: true difference in means is not equal to 0
## 95 percent confidence interval:
##  -0.6269680  0.1129285
## sample estimates:
## mean of x mean of y 
##  2.187555  2.444575
</code></pre>

<p>And, we observe that the findings from R match the hand calculations.  </p>

<p>####<em>Two dependent proportions</em><br/>
With two dependent proportions, you have a McNemar test.  Note that R will run this as a chi-squared (worry about the direction for one-sided in interpretation) while UvA runs this as a z-test (worry about the direction in the statistic set-up).  </p>

<p>Essentially, there are four things that can happen:  Good -&gt; Good, Good -&gt; Bad, Bad -&gt; Good, and Bad -&gt; Bad.  We are only actually interested in Good -&gt; Bad (GB) and Bad -&gt; Good (BG).  </p>

<ul>
<li>z = (BG - GB) / sqrt(BG + GB)<br/></li>
<li>chiSq = (BG - GB)<sup>2</sup> / (BG + GB)<br/></li>
</ul>

<p>Suppose we have a grid of 311, 34 (BG), 17 (GB), 14.  We only care about the 34 and the 17:  </p>

<pre><code class="r">zTest &lt;- (34 - 17) / sqrt(34 + 17)
zPStat &lt;- 1 - 2 * abs(pnorm(zTest) - 0.5)
print(paste0(&quot;Using z-test, we have z: &quot;,round(zTest,3),&quot; with two-sided p: &quot;,round(zPStat,3)))
</code></pre>

<pre><code>## [1] &quot;Using z-test, we have z: 2.38 with two-sided p: 0.017&quot;
</code></pre>

<pre><code class="r">## Compare to R
mcnemar.test(x=matrix(data=c(311,34,17,14),nrow=2,byrow=TRUE),correct=FALSE)
</code></pre>

<pre><code>## 
##  McNemar&#39;s Chi-squared test
## 
## data:  matrix(data = c(311, 34, 17, 14), nrow = 2, byrow = TRUE)
## McNemar&#39;s chi-squared = 5.6667, df = 1, p-value = 0.01729
</code></pre>

<p>Except for the use of chi-squared vs. z-statistic, the outputs are substantially the same.  </p>

<p>####<em>Two dependent means</em><br/>
This test is much simpler to run since you have paired observations.  Essentially:  </p>

<ul>
<li>Test-statistic t = (x1-bar - x2-bar) / ( Sd / sqrt(n) )<br/></li>
<li>Sd is the standard deviation of the differences<br/></li>
<li>df = n-1<br/></li>
<li>CI = (x1-bar - x2-bar) +/- t(alpha/2) * Sd / sqrt(n)<br/></li>
</ul>

<p>Below is an example for a random normal added to a random normal:  </p>

<pre><code class="r">myVar1 &lt;- norm1
myVar2 &lt;- norm1 + rnorm(100,mean=0.5,sd=5)
myDiff &lt;- myVar1 - myVar2

muDiff &lt;- mean(myDiff)
sDiff &lt;- sd(myDiff)
nDiff &lt;- length(myDiff)
seDiff &lt;- sDiff / sqrt(nDiff)
dfDiff &lt;- nDiff - 1

tStatDiff &lt;- muDiff / seDiff
pStatDiff &lt;- 1 - 2 * abs(pnorm(tStatDiff) - 0.5)

print(paste0(&quot;The difference in means is: &quot;,round(muDiff,2),&quot; with standard error: &quot;,round(seDiff,2)))
</code></pre>

<pre><code>## [1] &quot;The difference in means is: -1.55 with standard error: 0.49&quot;
</code></pre>

<pre><code class="r">print(paste0(&quot;The t-statistic &quot;,round(tStatDiff,2),&quot; with df = &quot;,dfDiff,
             &quot; has two-sided significance &quot;,round(pStatDiff,3)
             )
      )
</code></pre>

<pre><code>## [1] &quot;The t-statistic -3.16 with df = 99 has two-sided significance 0.002&quot;
</code></pre>

<pre><code class="r">tCritical &lt;- qt(.05/2,lower.tail=FALSE,df=dfDiff)
print(paste0(&quot;The 95% CI for difference in means is: &quot;,
             paste(round(muDiff + c(-1,1) * seDiff * tCritical,3),collapse=&quot; , &quot;)
             )
      )
</code></pre>

<pre><code>## [1] &quot;The 95% CI for difference in means is: -2.515 , -0.576&quot;
</code></pre>

<pre><code class="r">## Compare with R
t.test(myVar1,myVar2,paired=TRUE)
</code></pre>

<pre><code>## 
##  Paired t-test
## 
## data:  myVar1 and myVar2
## t = -3.1638, df = 99, p-value = 0.002069
## alternative hypothesis: true difference in means is not equal to 0
## 95 percent confidence interval:
##  -2.5150923 -0.5762888
## sample estimates:
## mean of the differences 
##               -1.545691
</code></pre>

<p>As expected, the results from R match the associated hand calculations.  </p>

<h2>Module 2: Categorical Association</h2>

<p>Tests for categorical association check relative frequencies for two or more categories.  The typical test statistic is chi-squared.  Comparisons are made against an &ldquo;expected frequency&rdquo; which can be a theoretical frequency or the frequency that would be obtained by multiplying out row/column frequencies.  </p>

<p>The general approach to a test matrix is to put the explanatory variables in the rows and the response variable in the columns.  There is, of course, no actual meaningful correlation statistic since the column orders are arbitrary.  So, the general framing would be:</p>

<ul>
<li>Ho: The variables are all independent, which is to say P(row, column) = P(row) * P(column)<br/></li>
<li>Ha: There are one or more dependencies<br/></li>
<li>Approach:  Create a new table (expected) that is P(row) * P(column)<br/></li>
</ul>

<p>The example from the UvA course is used a few times in this module:  </p>

<pre><code class="r">artHistory &lt;- data.frame(fruit=c(11,8,3), flowers=c(5,6,10),mixed=c(1,8,12),
                         row.names=c(&quot;early&quot;,&quot;late&quot;,&quot;Baroque&quot;)
                         )
## Raw data frame
artHistory
</code></pre>

<pre><code>##         fruit flowers mixed
## early      11       5     1
## late        8       6     8
## Baroque     3      10    12
</code></pre>

<pre><code class="r">## Joint frequencies
jointFreqArt &lt;- artHistory/sum(artHistory)
jointFreqArt
</code></pre>

<pre><code>##            fruit  flowers    mixed
## early   0.171875 0.078125 0.015625
## late    0.125000 0.093750 0.125000
## Baroque 0.046875 0.156250 0.187500
</code></pre>

<pre><code class="r">## Marginal (column) frequencies
margColArt &lt;- colSums(artHistory)/sum(artHistory)
t(as.matrix(margColArt))
</code></pre>

<pre><code>##        fruit  flowers    mixed
## [1,] 0.34375 0.328125 0.328125
</code></pre>

<pre><code class="r">## Marginal (row) frequencies
margRowArt &lt;- rowSums(artHistory)/sum(artHistory)
as.matrix(margRowArt)
</code></pre>

<pre><code>##             [,1]
## early   0.265625
## late    0.343750
## Baroque 0.390625
</code></pre>

<pre><code class="r">## Expected frequencies = product of marginal frequencies
expArtHistory &lt;- ( as.matrix(margRowArt) %*% t(as.matrix(margColArt)) ) * sum(artHistory)
round(expArtHistory,1)
</code></pre>

<pre><code>##         fruit flowers mixed
## early     5.8     5.6   5.6
## late      7.6     7.2   7.2
## Baroque   8.6     8.2   8.2
</code></pre>

<p>####<em>Chi-squared test for association</em><br/>
The chi-squared statistic is then the sum over all cells of residual<sup>2</sup> / expected, which could also be formulated as sum over all cells of (observed - expected)<sup>2</sup> / expected.  </p>

<p>The chi-squared statistics can then be assessed for its likelihood:  </p>

<ul>
<li>Test-statistic: sum over all cells of residual<sup>2/expected</sup><br/></li>
<li>df = (nrow - 1) * (ncol - 1)<br/></li>
<li>The mean of a chi-squared distribution with df=n will be n<br/></li>
<li>The chi-squared is always greater than or equal to zero<br/></li>
<li>pchisq(myStat, df=myDF, lower.tail=FALSE) brings back the odds of seeing &gt;= myStat given myDF<br/></li>
</ul>

<p>Note that we require n=5+ for each expected cell for this statistic to be reasonable.  </p>

<pre><code class="r">## The residuals data frame
resArtHistory &lt;- artHistory - expArtHistory
resArtHistory
</code></pre>

<pre><code>##            fruit   flowers     mixed
## early    5.15625 -0.578125 -4.578125
## late     0.43750 -1.218750  0.781250
## Baroque -5.59375  1.796875  3.796875
</code></pre>

<pre><code class="r">## Test Statistic method 1 -- residual^2 / expected
testMatrix1 &lt;- resArtHistory^2 / expArtHistory
testMatrix1
</code></pre>

<pre><code>##              fruit    flowers      mixed
## early   4.54963235 0.05991772 3.75739671
## late    0.02530992 0.20576299 0.08455087
## Baroque 3.64102273 0.39360119 1.75741071
</code></pre>

<pre><code class="r">testStat1 &lt;- sum(testMatrix1)
testStat1
</code></pre>

<pre><code>## [1] 14.47461
</code></pre>

<pre><code class="r">## Test statistics method 2 -- (observed/expected - 1)^2
testMatrix2 &lt;- (artHistory - expArtHistory)^2 / expArtHistory
testMatrix2
</code></pre>

<pre><code>##              fruit    flowers      mixed
## early   4.54963235 0.05991772 3.75739671
## late    0.02530992 0.20576299 0.08455087
## Baroque 3.64102273 0.39360119 1.75741071
</code></pre>

<pre><code class="r">testStat2 &lt;- sum(testMatrix2)
testStat2
</code></pre>

<pre><code>## [1] 14.47461
</code></pre>

<pre><code class="r">## Calculate df
dfArt &lt;- (ncol(artHistory) - 1) * (nrow(artHistory) - 1)
dfArt
</code></pre>

<pre><code>## [1] 4
</code></pre>

<pre><code class="r">## Report on pStatistic
pStat &lt;- pchisq(testStat1, df=dfArt, lower.tail=FALSE)
print(paste0(&quot;Chi-squared is &quot;,round(testStat1,2),&quot; on df=&quot;,dfArt,&quot; for p=&quot;,round(pStat,4)))
</code></pre>

<pre><code>## [1] &quot;Chi-squared is 14.47 on df=4 for p=0.0059&quot;
</code></pre>

<pre><code class="r">## No surprise that this matches R
chisq.test(artHistory,correct=FALSE)
</code></pre>

<pre><code>## 
##  Pearson&#39;s Chi-squared test
## 
## data:  artHistory
## X-squared = 14.475, df = 4, p-value = 0.005925
</code></pre>

<p>####<em>Interpretation of chi-squared</em><br/>
There are two ways to help with interpreting chi-squared.  Recall that as df increases, you expect chi-squared to increase, so there is no specific meaning to &ldquo;this has chi-squared 6 while that has chi-squared 12&rdquo;.  </p>

<ul>
<li>Cramer&#39;s V is an attempt to standardize the chi-squared to within 0-1 where 0 means &ldquo;no association&rdquo; and 1 means &ldquo;perfect association&rdquo;.  The challenge is that V tends to increase no matter what as the matrix becomes less square, so it is still not a perfect test.<br/></li>
<li>Standarized residuals give a sense for how far each cell in the observed matrix is from expected.  It is reported on either a Pearson basis or a residuals basis.<br/></li>
</ul>

<p>The calculation for Cramer&#39;s V is as follows:  </p>

<ul>
<li>V = sqrt(chi-squared / (n * m))<br/></li>
<li>n = total cells in the matrix<br/></li>
<li>m = lesser of # rows or # columns, then subtract 1<br/></li>
</ul>

<p>There are two means of calculating the standardized residuals:  </p>

<ul>
<li>Pearson - residual / sqrt(expected)<br/></li>
<li>Standraized - resiudal / sqrt(V)<br/></li>
<li>V for a given cell =  expNCell * (1 - Prow) * (1 - Pcol)<br/></li>
<li>The standardized residuals follow a z-distribution<br/></li>
</ul>

<p>The code chunks below are copied from CheckChiSq_v001.Rmd:  </p>

<pre><code class="r">testFrame &lt;- data.frame(colI = c(5, 34, 33), colII = c(6, 47, 32), 
                        colIII = c(9, 48, 14), row.names=c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;)
                        )
testFrame
</code></pre>

<pre><code>##   colI colII colIII
## A    5     6      9
## B   34    47     48
## C   33    32     14
</code></pre>

<pre><code class="r">expMatrix &lt;- as.matrix(rowSums(testFrame)) %*% t(as.matrix(colSums(testFrame)))
expMatrix &lt;- expMatrix / sum(testFrame)
round(expMatrix,1)
</code></pre>

<pre><code>##   colI colII colIII
## A  6.3   7.5    6.2
## B 40.7  48.1   40.2
## C 24.9  29.5   24.6
</code></pre>

<pre><code class="r">resMatrix &lt;- testFrame - expMatrix
round(resMatrix,1)
</code></pre>

<pre><code>##   colI colII colIII
## A -1.3  -1.5    2.8
## B -6.7  -1.1    7.8
## C  8.1   2.5  -10.6
</code></pre>

<pre><code class="r">testChiSq &lt;- sum(resMatrix^2 / expMatrix)
nR &lt;- nrow(resMatrix)
nC &lt;- ncol(resMatrix)

dfChiSq &lt;- (nR - 1) * (nC - 1)
cramerV &lt;- sqrt(testChiSq / (nR * nC) / (min(nR, nC) - 1) )

## Pearson residuals - (obs - exp) / sqrt(exp)
prsMatrix &lt;- resMatrix / sqrt(expMatrix)

## Standardized residuals - (obs - exp) / sqrt(V)
## Vij = sqrt(Expij * (1 - pRow) * (1 - pCol))
stdMatrix &lt;- resMatrix / 
             sqrt(expMatrix * 
                   (as.matrix(1 - rowSums(expMatrix)/sum(expMatrix)) 
                    %*%             
                    t(as.matrix(1-colSums(expMatrix)/sum(expMatrix)))
                    )
                  )

print(paste0(&quot;Chi-squared is &quot;,round(testChiSq,2),&quot; with df=&quot;,dfChiSq,
             &quot; (p=&quot;,
             round(pchisq(testChiSq, df=dfChiSq, lower.tail=FALSE),4),
             &quot;)&quot;
             )
      )
</code></pre>

<pre><code>## [1] &quot;Chi-squared is 11.84 with df=4 (p=0.0185)&quot;
</code></pre>

<pre><code class="r">print(paste0(&quot;Cramer&#39;s V is: &quot;,round(cramerV,3)))
</code></pre>

<pre><code>## [1] &quot;Cramer&#39;s V is: 0.811&quot;
</code></pre>

<pre><code class="r">## Pearson residuals - (obs - exp) / sqrt(exp)
round(prsMatrix,2)
</code></pre>

<pre><code>##    colI colII colIII
## A -0.52 -0.53   1.11
## B -1.06 -0.16   1.24
## C  1.61  0.47  -2.14
</code></pre>

<pre><code class="r">## Standardized residuals - (obs - exp) / sqrt(V)
## Vij = sqrt(Expij * (1 - pRow) * (1 - pCol))
round(stdMatrix,2)
</code></pre>

<pre><code>##    colI colII colIII
## A -0.66 -0.70   1.40
## B -1.94 -0.30   2.26
## C  2.41  0.73  -3.19
</code></pre>

<pre><code class="r">testChi &lt;- chisq.test(testFrame)
for (intCtr in 1:length(testChi)) {
    print(testChi[intCtr])
}
</code></pre>

<pre><code>## $statistic
## X-squared 
##  11.84471 
## 
## $parameter
## df 
##  4 
## 
## $p.value
## [1] 0.01854417
## 
## $method
## [1] &quot;Pearson&#39;s Chi-squared test&quot;
## 
## $data.name
## [1] &quot;testFrame&quot;
## 
## $observed
##   colI colII colIII
## A    5     6      9
## B   34    47     48
## C   33    32     14
## 
## $expected
##        colI    colII   colIII
## A  6.315789  7.45614  6.22807
## B 40.736842 48.09211 40.17105
## C 24.947368 29.45175 24.60088
## 
## $residuals
##         colI      colII    colIII
## A -0.5235674 -0.5332688  1.110722
## B -1.0555108 -0.1574808  1.235227
## C  1.6122243  0.4695542 -2.137305
## 
## $stdres
##         colI      colII    colIII
## A -0.6626947 -0.7049874  1.401389
## B -1.9365006 -0.3017705  2.258989
## C  2.4110425  0.7334312 -3.186093
</code></pre>

<pre><code class="r">## Borrowed from http://www.r-bloggers.com/example-8-39-calculating-cramers-v/
## With adaptations
cv.test &lt;- function(x) {
    CV &lt;- sqrt(chisq.test(x, correct=FALSE)$statistic /
               (sum(!is.na(x)) * (min(nrow(x), ncol(x)) - 1) )
               )

    print.noquote(&quot;Cramér V / Phi:&quot;)

    return(as.numeric(CV))
}

cv.test(testFrame)
</code></pre>

<pre><code>## [1] Cramér V / Phi:
</code></pre>

<pre><code>## [1] 0.8111964
</code></pre>

<p>The R functions (chisq.test and cv.test) match with the hand calculations as expected.  </p>

<p>####<em>Running chi-squared as &ldquo;goodness of fit&rdquo;</em><br/>
The chi-squared test can also be run to compare some actual observations against a theoretical distribution.  There are a few modest changes:  </p>

<ul>
<li>Ho: Observed does not differ from expected based on theory<br/></li>
<li>Ha: Observed differs in at least some regard from expected based on theory<br/></li>
<li>Test statistic chi-squared is sum-over-columns of (observed - expected)<sup>2</sup> / expected<br/></li>
<li>df = N-1 where there are N columns explored<br/></li>
<li>Requirement that expected be 5+ in each column<br/></li>
</ul>

<p>Expected is generally a vector of probabilities summing to 1, with expected for each column become T*expected where T is the sum across all of the observed elements.  </p>

<p>An obvious but important caution is that this is absolutely NOT an appropriate way to compare two rows of observed data against each other!  This only works when you have a theoretical expectation prior to experimentation, and an observed dataset during your experiment plainly does not qualify!  </p>

<p>See below for a very simple example:  </p>

<pre><code class="r">myVector &lt;- c(5,20,10,35)
myTheory &lt;- c(.2,.3,.1,.4)

chiSqAssoc &lt;- (myVector - (sum(myVector) * myTheory) )^2 / ( sum(myVector) * myTheory) 
chiSqAssoc
</code></pre>

<pre><code>## [1] 5.78571429 0.04761905 1.28571429 1.75000000
</code></pre>

<pre><code class="r">dfAssoc &lt;- length(chiSqAssoc) - 1
pStat &lt;- pchisq(sum(chiSqAssoc), df=dfAssoc, lower.tail=FALSE)

print(paste0(&quot;Chi-squared is &quot;, round(sum(chiSqAssoc),2),
             &quot; with df=&quot;,dfAssoc,&quot; for p=&quot;,round(pStat,4)
             )
      )
</code></pre>

<pre><code>## [1] &quot;Chi-squared is 8.87 with df=3 for p=0.0311&quot;
</code></pre>

<pre><code class="r">chisq.test(myVector, correct=FALSE,p=myTheory)
</code></pre>

<pre><code>## 
##  Chi-squared test for given probabilities
## 
## data:  myVector
## X-squared = 8.869, df = 3, p-value = 0.03108
</code></pre>

<p>As expected, the results from R functions match the hand calculations.  </p>

<p>####<em>Side notes for chi-squared tests</em><br/>
Sometimes, not all of the conditions for chi-squared testing are met.  To wit:  </p>

<ul>
<li>Data from a non-random sample (frequent error; make sure your experiment is properly randomized)<br/></li>
<li>Categories are not exclusive (make sure you have a column for Both-A-and-B and do not count +1 in both the A and B columns)<br/></li>
<li>Categories are not exhaustive (make sure everything can be placed somewhere, even if just All Other)<br/></li>
<li>Sample too small; requires expected values of 5+ per call (aggregate as needed if not)<br/></li>
<li>Interpreting chi-squared as goodness of association (no way - Cramer&#39;s V at least gets you in the right direction)<br/></li>
<li>Interpreting a high p-value as &ldquo;support of theory&rdquo; (as with all hypothesis testing, all we will ever do is fail to reject the null hypothesis; we do not accept/confirm the null!)<br/></li>
</ul>

<p>####<em>Fisher&#39;s exact test</em><br/>
The Fisher&#39;s exact test is the solution when you have a contained, small-n problem which precludes using chi-squared tests of association.  </p>

<p>The test is generally designed for a 2x2 table as follows:  </p>

<table><thead>
<tr>
<th>a</th>
<th>b</th>
<th>(a+b)</th>
</tr>
</thead><tbody>
<tr>
<td>c</td>
<td>d</td>
<td>(c+d)</td>
</tr>
<tr>
<td>(a+c)</td>
<td>(b+d)</td>
<td>(a+b+c+d)</td>
</tr>
</tbody></table>

<p>Define n=(a+b+c+d).  This configuration can occur (a+c)! * (b+d)! * (a+b)! * (c+d)! / [n! * a! * b! * c! * d!] of the time.  So, if a were the critical value, you could test how likely (one-sided or two-sided) you are to get the specific or more extreme value for a.</p>

<p>Recall that if you do not have a small-n problem, you use chi-squared!  This test is something of a mess.  See associated R code:  </p>

<pre><code class="r">nTotal &lt;- 23
nAplusB &lt;- 10
nAplusC &lt;- 8

fishStore &lt;- data.frame(a=0:min(nAplusB,nAplusC),probA=rep(-1,min(nAplusB,nAplusC)+1))

for (intCtr in 1:(min(nAplusB,nAplusC)+1)) {
    a &lt;- intCtr - 1
    b &lt;- nAplusB - a
    c &lt;- nAplusC - a
    d &lt;- nTotal - a - b - c
    numer1 &lt;- factorial(a+c) * factorial(b+d)
    numer2 &lt;- factorial(a+b) * factorial(c+d)
    denom1 &lt;- factorial(nTotal)
    denom2 &lt;- factorial(a) * factorial(b) * factorial(c) * factorial(d)
    fishStore[intCtr,&quot;probA&quot;] &lt;- (numer1/denom1) * (numer2/denom2)
}

fishStore
</code></pre>

<pre><code>##   a        probA
## 1 0 2.624849e-03
## 2 1 3.499798e-02
## 3 2 1.574909e-01
## 4 3 3.149818e-01
## 5 4 3.062323e-01
## 6 5 1.469915e-01
## 7 6 3.340716e-02
## 8 7 3.181635e-03
## 9 8 9.177792e-05
</code></pre>

<pre><code class="r">sum(fishStore[c(0,8),&quot;probA&quot;])
</code></pre>

<pre><code>## [1] 0.003181635
</code></pre>

<pre><code class="r">fisher.test(matrix(data=c(0,10,8,5),nrow=2,byrow=TRUE))$p.value
</code></pre>

<pre><code>## [1] 0.002716626
</code></pre>

<pre><code class="r">fisher.test(matrix(data=c(1,9,7,6),nrow=2,byrow=TRUE))$p.value
</code></pre>

<pre><code>## [1] 0.07430341
</code></pre>

<pre><code class="r">fisher.test(matrix(data=c(2,8,6,7),nrow=2,byrow=TRUE))$p.value
</code></pre>

<pre><code>## [1] 0.3787858
</code></pre>

<pre><code class="r">fisher.test(matrix(data=c(3,7,5,8),nrow=2,byrow=TRUE))$p.value
</code></pre>

<pre><code>## [1] 1
</code></pre>

<pre><code class="r">fisher.test(matrix(data=c(4,6,4,9),nrow=2,byrow=TRUE))$p.value
</code></pre>

<pre><code>## [1] 0.6850182
</code></pre>

<pre><code class="r">fisher.test(matrix(data=c(5,5,3,10),nrow=2,byrow=TRUE))$p.value
</code></pre>

<pre><code>## [1] 0.2212949
</code></pre>

<pre><code class="r">fisher.test(matrix(data=c(6,4,2,11),nrow=2,byrow=TRUE))$p.value
</code></pre>

<pre><code>## [1] 0.03930542
</code></pre>

<pre><code class="r">fisher.test(matrix(data=c(7,3,1,12),nrow=2,byrow=TRUE))$p.value
</code></pre>

<pre><code>## [1] 0.005898261
</code></pre>

<pre><code class="r">fisher.test(matrix(data=c(8,2,0,13),nrow=2,byrow=TRUE))$p.value
</code></pre>

<pre><code>## [1] 9.177792e-05
</code></pre>

<p>These still do not match perfectly.  I get the sense this is a rarely used test, but time permitting it may be good to figure out the discrepancy.  </p>

<h2>Module 3: Simple Regression</h2>

<p>Simple Linear Regression ultimately reduces (perhaps after transformations) to y-hat(i) = a + b * x-hat(i).  The lingo is such that x is the &ldquo;predictor&rdquo; variable and y is the &ldquo;response&rdquo; variable.  </p>

<p>####<em>Regression equation</em><br/>
The goal is to use Ordinary Least Squares (OLS) to minimize the sum-squared distance of the residuals (errors).  Specifically, a few of the key calculations include:  </p>

<ul>
<li>min( [y(i) - y-hat(i)]<sup>2</sup> )<br/></li>
<li>df/da ( [y(i) - (a + b * x(i))]<sup>2</sup> ) = 0</li>
<li>df/db ( [y(i) - (a + b * x(i))]<sup>2</sup> ) = 0<br/></li>
</ul>

<p>Ultimately, these equations reduce to the following:  </p>

<ul>
<li>b = r * Sy / Sx, where r is the Pearson correlation and Sy/Sx are the respective standard deviations<br/></li>
<li>a = y-bar - b * x-bar<br/></li>
<li>r is considered small at 0.3, medium at 0.5, and large at 0.8<br/></li>
</ul>

<p>Once you have created OLS on your sample, you infer that it applies to a broader population, allowing you to make predictions.  At this point, we move back to Greek (population) letters, and assume that the population has normally distributed y, centered on predicted mu(y), for each x.  </p>

<p>There are two ways to express this:  </p>

<ul>
<li>mu(y) = alpha + Beta * x  &ndash; with constant sigma<br/></li>
<li>y(i) = alpha + beta * x(i) + epsilon(i) &ndash; epsilon(i) having mean zero and sd sigma<br/></li>
</ul>

<p>####<em>Predictive power (Sum of Squares)</em><br/>
The predictive power r<sup>2</sup> is derived by squaring the Pearson correlation.  This can be interpreted as the proportion of explained variance.  The typical approach is Sum of Squares, as follows:  </p>

<ul>
<li>Total Sum of Squares = sum-over-i-of ( y(i) - y-bar )<sup>2,</sup> or the total variability in y from its mean<br/></li>
<li>Residual Sum of Squares = sum-over-i-of ( y(i) - y-hat(i) )<sup>2,</sup> or the total variability in y from its best-fit regression line estimate<br/></li>
<li>Regression Sum of Squares = Total Sum of Squares - Residual Sum of Squares<br/></li>
<li>r<sup>2</sup> = Resgression Sum of Squares / Total Sum of Squares<br/></li>
</ul>

<p>So, when r<sup>2=1,</sup> the regression explains everything, and when r<sup>2=0,</sup> the regression explains nothing.  </p>

<p>See below for an example from the R dataset airquality:  </p>

<pre><code class="r">data(airquality)
myData &lt;- airquality[,c(&quot;Ozone&quot;,&quot;Temp&quot;,&quot;Month&quot;)]
myData &lt;- myData[complete.cases(myData),]

pairs(myData) ## Many issues with the data -- using just as an example
</code></pre>

<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-10"/></p>

<pre><code class="r">estBeta &lt;- cor(myData$Ozone, myData$Temp) * sd(myData$Ozone) / sd(myData$Temp)
estAlpha &lt;- mean(myData$Ozone) - estBeta * mean(myData$Temp)

estTSS &lt;- sum( (myData$Ozone - mean(myData$Ozone))^2 )
estResSS &lt;- sum( (myData$Ozone - (estAlpha + estBeta * myData$Temp))^2 )
estRegSS &lt;- estTSS - estResSS
estR2 &lt;- estRegSS / estTSS

dfReg &lt;- 1 ## 1 predictor
dfRes &lt;- length(myData$Ozone) - 2 ## 1 for mean, 1 for single predictor

meanResSS &lt;- estResSS / dfRes
meanRegSS &lt;- estRegSS / dfReg
stdResSS &lt;- sqrt(meanResSS)

print(paste0(&quot;Estimated regression is Ozone = &quot;,round(estAlpha,1),&quot; + &quot;,
             round(estBeta,2),&quot; * Temp, constant sigma&quot;
             )
      )
</code></pre>

<pre><code>## [1] &quot;Estimated regression is Ozone = -147 + 2.43 * Temp, constant sigma&quot;
</code></pre>

<pre><code class="r">print(paste0(&quot;TSS: &quot;,round(estTSS,1),&quot; ResSS: &quot;,round(estResSS,1),
             &quot; RegSS: &quot;,round(estRegSS,1),&quot; r^2: &quot;,round(estR2,3),
             &quot; Standard Residual &quot;,round(stdResSS,2),&quot; on df=&quot;,dfRes
             )
      )
</code></pre>

<pre><code>## [1] &quot;TSS: 125143.1 ResSS: 64109.9 RegSS: 61033.2 r^2: 0.488 Standard Residual 23.71 on df=114&quot;
</code></pre>

<pre><code class="r">print(paste0(&quot;Mean Residual SS: &quot;,round(meanResSS,2),
             &quot; and Mean Regression SS: &quot;,round(meanRegSS,2),
             &quot; for F=&quot;,round(meanRegSS/meanResSS,1),&quot; on df &quot;,
             dfReg,&quot; , &quot;,dfRes
             )
      )
</code></pre>

<pre><code>## [1] &quot;Mean Residual SS: 562.37 and Mean Regression SS: 61033.17 for F=108.5 on df 1 , 114&quot;
</code></pre>

<pre><code class="r">print(paste0(&quot;Associated p-value is: &quot;,
             round(pf(meanRegSS/meanResSS,df1=dfReg, df2=dfRes,lower.tail=FALSE),3)
             )
      )
</code></pre>

<pre><code>## [1] &quot;Associated p-value is: 0&quot;
</code></pre>

<pre><code class="r">## Comparison to running this in R
regR &lt;- lm(Ozone ~ Temp, data=myData)
summary(regR)
</code></pre>

<pre><code>## 
## Call:
## lm(formula = Ozone ~ Temp, data = myData)
## 
## Residuals:
##     Min      1Q  Median      3Q     Max 
## -40.729 -17.409  -0.587  11.306 118.271 
## 
## Coefficients:
##              Estimate Std. Error t value Pr(&gt;|t|)    
## (Intercept) -146.9955    18.2872  -8.038 9.37e-13 ***
## Temp           2.4287     0.2331  10.418  &lt; 2e-16 ***
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Residual standard error: 23.71 on 114 degrees of freedom
## Multiple R-squared:  0.4877, Adjusted R-squared:  0.4832 
## F-statistic: 108.5 on 1 and 114 DF,  p-value: &lt; 2.2e-16
</code></pre>

<pre><code class="r">sum(regR$residuals^2)
</code></pre>

<pre><code>## [1] 64109.89
</code></pre>

<pre><code class="r">## Graph this
plot(x=myData$Temp,y=myData$Ozone,pch=20,col=&quot;blue&quot;)
lines(x=myData$Temp,y=regR$fitted.values,col=&quot;dark green&quot;,lwd=4)
</code></pre>

<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-10"/></p>

<p>As expected, the call to lm() in R produces the same outputs as the hand calculations.  </p>

<p>####<em>Potential Pitfalls in Regression</em><br/>
There are many potential problems that can throw off the OLS approach, including but not limited to:  </p>

<ul>
<li>Nonlinearity - as in the Ozone example above, where Ozone is ~0 for all low-ish temperatures<br/></li>
<li>Outliers - especially problematic for small-n regression or large deviation on x/y from regression line<br/></li>
<li>Intepreting correlation as causality - this is just a model that y ~ x, not (necessarily) that x causes y<br/></li>
<li>Inappropriate extrapolation - for example, above only has temperatures 60-90, cannot predict 30 or 120<br/></li>
<li>Ecological fallacy - drawing conclusions about individuals after running a group model (for example, if aggregating students by state, drawing conclusions about a specific student in state X based on the model)<br/></li>
<li>Restriction of range &ndash; sample contains a very limited range of predictors (x variables)<br/></li>
</ul>

<p>In addition, there are many assumptions that we should investigate/validate during the regression process:  </p>

<ul>
<li>Linearity of response and predictor relationships - eyeball test on scatterplot<br/></li>
<li>Normality can be assessed by examining the residuals - eyeball test<br/></li>
<li>Outliers can be investigates using standardized residuals, where &ldquo;more extreme than +/- 3 is a concern&rdquo;</li>
<li>Homoscedasticity can be assessed by graphing residuals vs. predictors to see if they have equal dispersion for all values of predictor<br/></li>
<li>Independence of errors means they are not related to each other; particularly an issue for time series<br/></li>
</ul>

<p>The key theme is to look at a scatterplot.  The pairs() function showed that we have some issues in the regression run above which we would need to address if we wanted to take action based on this regression.  </p>

<p>####<em>Testing the model, including PI and CI</em><br/>
We can run hypothesis tests on whether our model beta is significant:  </p>

<ul>
<li>Ho: Beta = 0<br/></li>
<li>Ha: Beta &lt;&gt; 0<br/></li>
<li>Test statistic: t = Beta / seBeta , df = n-2 where n is total observations<br/></li>
<li>CI = Beta +/- critical-t * seBeta<br/></li>
</ul>

<p>Further, we can calculate some key statistics about the quality of our predictions:  </p>

<ul>
<li>Prediction Interval (PI) for predicted individual response<br/></li>
<li><p>Confidence Interval (CI) for predicted population means  </p></li>
<li><p>CI of the mean: CI for mu(y) = y-hat +/- t-critical * S(Res) / sqrt(n)  </p></li>
<li><p>PI of an individual: PI for y(i) = y-hat +/- t-critical * S(Res)  </p></li>
<li><p>S(Res) is the SE of the residual, defines as sqrt(Residual SS / (n-2))  </p></li>
<li><p>n is the total number of observations  </p></li>
</ul>

<p>We can take a look at some residuals and the above statistics for our previous Ozone ~ Temp call:  </p>

<pre><code class="r">## Re-print for convenience
print(paste0(&quot;TSS: &quot;,round(estTSS,1),&quot; ResSS: &quot;,round(estResSS,1),
             &quot; RegSS: &quot;,round(estRegSS,1),&quot; r^2: &quot;,round(estR2,3),
             &quot; Standard Residual &quot;,round(stdResSS,2),&quot; on df=&quot;,dfRes
             )
      )
</code></pre>

<pre><code>## [1] &quot;TSS: 125143.1 ResSS: 64109.9 RegSS: 61033.2 r^2: 0.488 Standard Residual 23.71 on df=114&quot;
</code></pre>

<pre><code class="r">summary(regR)
</code></pre>

<pre><code>## 
## Call:
## lm(formula = Ozone ~ Temp, data = myData)
## 
## Residuals:
##     Min      1Q  Median      3Q     Max 
## -40.729 -17.409  -0.587  11.306 118.271 
## 
## Coefficients:
##              Estimate Std. Error t value Pr(&gt;|t|)    
## (Intercept) -146.9955    18.2872  -8.038 9.37e-13 ***
## Temp           2.4287     0.2331  10.418  &lt; 2e-16 ***
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Residual standard error: 23.71 on 114 degrees of freedom
## Multiple R-squared:  0.4877, Adjusted R-squared:  0.4832 
## F-statistic: 108.5 on 1 and 114 DF,  p-value: &lt; 2.2e-16
</code></pre>

<pre><code class="r">plot(x=myData$Temp,y=regR$residuals)
abline(h=0)
</code></pre>

<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-11"/></p>

<pre><code class="r">plot(x=myData$Ozone,y=regR$residuals)
abline(h=0)
</code></pre>

<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-11"/></p>

<p>As before, we match the outputs from R.  The residuals are plausibly OK when plotted against temperature, but clearly flawed when plotted against Ozone.  This is likely due to the non-linearity observed in the original dataset, and signals that we would need to clean the data or explore a different model before proceeding.  </p>

<p>####<em>Exponential Regression</em><br/>
While there are many types of nonlinear regression, the exponential form is especially nice since it reduces easily to the linear form.  The regression can be expressed as:  </p>

<ul>
<li>y = a * b<sup>x</sup><br/></li>
<li>mu(y) = alpha * Beta<sup>x</sup><br/></li>
<li>These are commonly time regressions, so mu(y) = alpha * Beta<sup>t</sup> is common to see<br/></li>
</ul>

<p>This formulation can easily be reduced to a linear form:  </p>

<ul>
<li>ln( y-hat ) = ln(alpha) + x * ln(beta)<br/></li>
<li>ln( y-hat ) = A + B * x , where A = ln(alpha) and B=ln(beta)<br/></li>
</ul>

<p>An example with the airquality dataset:  </p>

<pre><code class="r">myLNData &lt;- myData
myLNData$Ozone &lt;- log(myData$Ozone)

regLNR &lt;- lm(Ozone ~ Temp , data=myLNData)

alphaLN &lt;- exp(regLNR$coefficients[[1]])
betaLN &lt;- exp(regLNR$coefficients[[2]])

print(paste0(&quot;We predict alpha: &quot;,round(alphaLN,3),&quot; and beta: &quot;,round(betaLN,3)))
</code></pre>

<pre><code>## [1] &quot;We predict alpha: 0.159 and beta: 1.07&quot;
</code></pre>

<pre><code class="r">plot(myData$Temp, myData$Ozone, pch=20, col=&quot;blue&quot;)
lines(x=60:90,y=alphaLN*(60:90)^betaLN,lwd=4,col=&quot;dark green&quot;)
</code></pre>

<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-12"/></p>

<pre><code class="r">## R nonlinear least squares outputs
myNLS &lt;- nls(Ozone ~ a * b^Temp, data=myData, start=list(a=1, b=1))
summary(myNLS)
</code></pre>

<pre><code>## 
## Formula: Ozone ~ a * b^Temp
## 
## Parameters:
##   Estimate Std. Error t value Pr(&gt;|t|)    
## a 0.298900   0.158536   1.885   0.0619 .  
## b 1.063533   0.006498 163.672   &lt;2e-16 ***
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Residual standard error: 22.66 on 114 degrees of freedom
## 
## Number of iterations to convergence: 14 
## Achieved convergence tolerance: 2.988e-07
</code></pre>

<p>The data from OLS on the linear transformation closely matches the approxiamtaion from R using NLS.  It is obviously not an appropriate fit given this data!  </p>

<h2>Module 4: Multiple Regression</h2>

<p>Multiple regression expands simple regression by moving to two or more predictors.  These may be needed to increase explanatory power or to relieve confounders.  The assumptions are similar, although there is now a best-fit plane to describe the mean, still with the assumption that residuals all have the same sigma and are normally distributed.  </p>

<p>The multiple regression equation can include:  </p>

<ul>
<li>Sample: y-hat(i) = a + b1 * x1(i) + b2 *x2(i) + &hellip; + bn * xn(i)<br/></li>
<li>Population: mu(y) = alpha + beta1 * x1 + beta2 * x2 + &hellip;+ betan * xn<br/></li>
</ul>

<p>####<em>Multiple R and R-Squared</em><br/>
Similar to simple regression, multiple regression can be described by both R and R<sup>2.</sup>  These are:  </p>

<ul>
<li>R is the multiple correlation coefficient (always non-negative 0 &lt;= R &lt;= 1) that describes how strongly the response variable is related to the SET of predictor variables<br/></li>
<li>R<sup>2</sup> is the explained variation as a proportion, and is still Regression Sum-Squares / Total Sum-Squares<br/></li>
<li>Multiple-R is sqrt(R<sup>2)</sup> and R<sup>2</sup> is (multiple-R)<sup>2</sup><br/></li>
</ul>

<p>The multiple-R is based on several correlations.  For example, suppose you have response variable y with predictor variables x1, x2.  Define and use simple correlations as:  </p>

<ul>
<li>CorYX1 = cor(y, x1)<br/></li>
<li>CorYX2 = cor(y, x2)<br/></li>
<li>CorX1X2 = cor(x1, x2)<br/></li>
<li>R = sqrt[ (CorYX1<sup>2</sup> + CorYX2<sup>2</sup> - 2 * CorYX1 * CorYX2 * CorX1X2) / (1 - CorX1X2<sup>2)</sup> ]<br/></li>
</ul>

<p>An example can be shown using the dataset mtcars, which will have something of a collinearity problem:  </p>

<pre><code class="r">data(mtcars)
myMulti &lt;- mtcars[,c(&quot;mpg&quot;,&quot;cyl&quot;,&quot;wt&quot;)]
pairs(myMulti)
</code></pre>

<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-13"/></p>

<pre><code class="r">corYX1&lt;- cor(mtcars$mpg,mtcars$cyl)
corYX2&lt;- cor(mtcars$mpg,mtcars$wt)
corX1X2&lt;- cor(mtcars$wt,mtcars$cyl)

multiR &lt;- sqrt( (corYX1^2 + corYX2^2 - 2*corYX1*corYX2*corX1X2) / (1 - corX1X2^2) )

print(paste0(&quot;Correlations include MPG-CYL: &quot;,round(corYX1,3),
             &quot; MPG-WT: &quot;,round(corYX2,3),&quot; CYL-WT: &quot;,round(corX1X2,3)
             )
      )
</code></pre>

<pre><code>## [1] &quot;Correlations include MPG-CYL: -0.852 MPG-WT: -0.868 CYL-WT: 0.782&quot;
</code></pre>

<pre><code class="r">print(paste0(&quot;Multiple R is &quot;,round(multiR,4),&quot; for R-squared &quot;,round(multiR^2,4)))
</code></pre>

<pre><code>## [1] &quot;Multiple R is 0.9112 for R-squared 0.8302&quot;
</code></pre>

<pre><code class="r">summary(lm(mpg ~ cyl + wt, data=mtcars))
</code></pre>

<pre><code>## 
## Call:
## lm(formula = mpg ~ cyl + wt, data = mtcars)
## 
## Residuals:
##     Min      1Q  Median      3Q     Max 
## -4.2893 -1.5512 -0.4684  1.5743  6.1004 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(&gt;|t|)    
## (Intercept)  39.6863     1.7150  23.141  &lt; 2e-16 ***
## cyl          -1.5078     0.4147  -3.636 0.001064 ** 
## wt           -3.1910     0.7569  -4.216 0.000222 ***
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Residual standard error: 2.568 on 29 degrees of freedom
## Multiple R-squared:  0.8302, Adjusted R-squared:  0.8185 
## F-statistic: 70.91 on 2 and 29 DF,  p-value: 6.809e-12
</code></pre>

<p>The hand calculation for two-variable R matches what we get from the linear model in R.  </p>

<p>####<em>Overall Model Tests</em><br/>
The null hypothesis is that Beta1 = Beta2 = &hellip; = Betan = 0.  The alternate hypothesis is that at least one of the Beta is non-zero, which is to say that the predictors, alone or in combination, have explanatory power.<br/>
There are several core assumptions required for running a multiple regression, including:  </p>

<ul>
<li>Linearity - as before, requires linear relationships of Y vs. Xi<br/></li>
<li>Normal residuals<br/></li>
<li>Homoscedastic residuals &ndash; cannot grow/shrink as any of the Xi variables grow/shrink<br/></li>
<li>Independent residuals &ndash; especially important in time-series and the like<br/></li>
<li>Observations &gt; Predictors<br/></li>
</ul>

<p>The overall hypothesis test is assessed using the F statistic.  This is calculated as:  </p>

<ul>
<li>MSReg (Regression Mean Sum Squares) = Regression Sum Squares / (k-1), where k is explanatory variables + 1<br/></li>
<li>MSRes (Residual Mean Sum Squares) = Residual Sum Squares / (n-k), where n is the total observations<br/></li>
<li>F = MSReg / MSRes with df1=(k-1) and df2=(n-k) where k is &ldquo;explanatory variables + 1&rdquo; and n is total observations<br/></li>
</ul>

<p>So, continuing with the mtcars example, we have:  </p>

<pre><code class="r">mtTSS &lt;- sum( (mtcars$mpg - mean(mtcars$mpg) )^2 )
mtRegSS &lt;- multiR^2 * mtTSS
mtResSS &lt;- mtTSS - mtRegSS
dfReg &lt;- (2 + 1 - 1)  ## k-1 where k is explanatory + 1
dfRes &lt;- nrow(mtcars) - (2 + 1)  ## n-k where n is total and k is explanatory + 1

print(paste0(&quot;We have Mean Regression SS: &quot;,round(mtRegSS/dfReg,2),
             &quot; and Mean Resiudal SS: &quot;,round(mtResSS/dfRes,2)
             )
      )
</code></pre>

<pre><code>## [1] &quot;We have Mean Regression SS: 467.44 and Mean Resiudal SS: 6.59&quot;
</code></pre>

<pre><code class="r">print(paste0(&quot;This gives F: &quot;,round((mtRegSS/dfReg)/(mtResSS/dfRes),2),
             &quot; on df1=&quot;,dfReg,&quot; and df2=&quot;,dfRes,&quot; for p=&quot;,
             round(pf((mtRegSS/dfReg)/(mtResSS/dfRes),df1=dfReg,df2=dfRes,lower.tail=FALSE),4)
             )
      )
</code></pre>

<pre><code>## [1] &quot;This gives F: 70.91 on df1=2 and df2=29 for p=0&quot;
</code></pre>

<pre><code class="r">summary(lm(mpg ~ cyl + wt, data=mtcars))
</code></pre>

<pre><code>## 
## Call:
## lm(formula = mpg ~ cyl + wt, data = mtcars)
## 
## Residuals:
##     Min      1Q  Median      3Q     Max 
## -4.2893 -1.5512 -0.4684  1.5743  6.1004 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(&gt;|t|)    
## (Intercept)  39.6863     1.7150  23.141  &lt; 2e-16 ***
## cyl          -1.5078     0.4147  -3.636 0.001064 ** 
## wt           -3.1910     0.7569  -4.216 0.000222 ***
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Residual standard error: 2.568 on 29 degrees of freedom
## Multiple R-squared:  0.8302, Adjusted R-squared:  0.8185 
## F-statistic: 70.91 on 2 and 29 DF,  p-value: 6.809e-12
</code></pre>

<pre><code class="r">sum(resid(lm(mpg ~ cyl + wt, data=mtcars))^2) / (nrow(mtcars) - 3)
</code></pre>

<pre><code>## [1] 6.592137
</code></pre>

<p>And as before, the hand calculations match with what we see from the lm() function.  </p>

<p>####<em>Individual Predictor Tests</em><br/>
Individual t-tests help to explain whether any particular variable(s) have explanatory power, after controlling for the other variables.  The same assumptions as the overall model continue to apply.  </p>

<p>The hypothesis testing is familiar:  </p>

<ul>
<li>Ho: Beta(i) = 0 after controlling for other factors<br/></li>
<li>Ha: Beta(i) &lt;&gt; 0 after controlling for other factors<br/></li>
<li>Test Stat t = Beta(i) / seBeta(i), df=n-k where n is total observations and k is &ldquo;total predictors + 1&rdquo;<br/></li>
<li>CI for Beta(i) = Beta(i) +/- critical-T * seBeta(i), using df=n-k<br/></li>
</ul>

<p>Note that the power of an individual predictor may go up or down as other variables are added/subtracted from the overall model.  We can grab the CI and test-statistic directly from R:  </p>

<pre><code class="r">myA &lt;- lm(mpg ~ cyl + wt, data=mtcars)

summary(myA)
</code></pre>

<pre><code>## 
## Call:
## lm(formula = mpg ~ cyl + wt, data = mtcars)
## 
## Residuals:
##     Min      1Q  Median      3Q     Max 
## -4.2893 -1.5512 -0.4684  1.5743  6.1004 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(&gt;|t|)    
## (Intercept)  39.6863     1.7150  23.141  &lt; 2e-16 ***
## cyl          -1.5078     0.4147  -3.636 0.001064 ** 
## wt           -3.1910     0.7569  -4.216 0.000222 ***
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Residual standard error: 2.568 on 29 degrees of freedom
## Multiple R-squared:  0.8302, Adjusted R-squared:  0.8185 
## F-statistic: 70.91 on 2 and 29 DF,  p-value: 6.809e-12
</code></pre>

<pre><code class="r">myEst &lt;- as.data.frame(summary(myA)$coefficients)$&quot;Estimate&quot;
mySE &lt;- as.data.frame(summary(myA)$coefficients)$&quot;Std. Error&quot;
criticalT &lt;- qt(.025, df=(nrow(mtcars)-(2+1)), lower.tail=FALSE)
myLow &lt;- myEst - criticalT*mySE
myHigh &lt;- myEst + criticalT*mySE

myLow
</code></pre>

<pre><code>## [1] 36.178725 -2.355928 -4.739020
</code></pre>

<pre><code class="r">myHigh
</code></pre>

<pre><code>## [1] 43.1937976 -0.6596622 -1.6429245
</code></pre>

<pre><code class="r">confint.lm(myA)
</code></pre>

<pre><code>##                 2.5 %     97.5 %
## (Intercept) 36.178725 43.1937976
## cyl         -2.355928 -0.6596622
## wt          -4.739020 -1.6429245
</code></pre>

<p>And we see that the hand calculations off the summary of the lm match the confidence interval as (much more conveniently) created by way of confint.lm().  </p>

<p>####<em>Checking Assumptions</em><br/>
The key assumptions are very similar to simple regression and include but are not limited to:  </p>

<ul>
<li>Linearity - for any combination of other x, we need x(i) and y to be linearly related<br/></li>
<li>Normal errors - eyeball test of residuals, fairly robust to violations for two-sided large-N<br/></li>
<li>Homoscedastic errors - eyeball the residuals, see if errors get skinnier/fatter with x(i)<br/></li>
<li>Independence of errors - generally controlled by good experiment design, particularly a problem for time series<br/></li>
<li>Sufficient observations - rule of thumb for n &gt;= 10*m where m is the number of predictors<br/></li>
<li>Absaence of outliers - inspect any standardized residuals of greater than +/- 3<br/></li>
</ul>

<p>####<em>Categorical predictors and response variables</em><br/>
The categorical predictor is a binary variable introduced to indicate yes/no.  It is typically used for things like male/female or smoker/nonsmoker.  If you have three things of interest, you use two categorical variables, where 1 0 is A, 0 1 is B, and 0 0 is C.  These need to be such that there is no case of 1 1.  The regression is run as per usual.  </p>

<p>The categorical response variable leads to logistic regression (logit), and would typically be used if we are trying to determine the yes/no status of something.  For example, perhaps we are trying to predict what gets an entry selected as top-100 in a global competition.  Then, we will have an indicator variable that is 1 for selected and 0 for not selected.  </p>

<p>A common functional form for the logit is exp(alpha + beta * x)/(1 + exp(alpha + beta * x)).  There are some features of note to this prediction:  </p>

<ul>
<li>When beta is positive, it slopes up<br/></li>
<li>When beta is negative, it slopes down<br/></li>
<li>When beta is high-magintude, it is a fast ramp<br/></li>
<li>The inflection point y=0.5 occurs at x = -alpha/beta<br/></li>
</ul>

<p>To use this variable in regression, we first convert to odds and then take the natural logarithm.  For example:  </p>

<ul>
<li>Odds = P(win)/P(lose) = exp(alpha + beta * x)<br/></li>
<li>Log-odds = ln(odds) = alpha + beta * x<br/></li>
</ul>

<p>The results of a logit regression are reported in log-odds, with the estimates being &ldquo;change in log-odds per change in unit of predictor variable&rdquo;.  The coefficients may be referred to as the &ldquo;odds ratio&rdquo;.  The easiest way to get back to probability is to recall that p = odds / (1 + odds).  </p>

<p>Software will also output a classification table showing predicted (cut point is typically p &gt; 0.5) vs. actual.  There are a few key metrics:  </p>

<ul>
<li>Specificity = Correct Model Reject / Total Real World Reject<br/></li>
<li>Sensitivity = Correct Model Accept / Total Real World Accept<br/></li>
<li>Overall Percentage = Correct Model / Total Real World<br/></li>
</ul>

<p>Suppose that we modify the mtcars example a bit and explore:  </p>

<pre><code class="r">data(mtcars)
myMulti &lt;- mtcars[,c(&quot;mpg&quot;,&quot;cyl&quot;,&quot;wt&quot;)]
myMulti$mpgWin &lt;- myMulti$mpg &gt; 20
pairs(myMulti)
</code></pre>

<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-16"/></p>

<pre><code class="r">myModel &lt;- glm(mpgWin ~ wt + cyl, family=binomial(link=&quot;logit&quot;), data=myMulti)
summary(myModel)
</code></pre>

<pre><code>## 
## Call:
## glm(formula = mpgWin ~ wt + cyl, family = binomial(link = &quot;logit&quot;), 
##     data = myMulti)
## 
## Deviance Residuals: 
##      Min        1Q    Median        3Q       Max  
## -1.62926  -0.00003   0.00000   0.00002   1.51381  
## 
## Coefficients:
##              Estimate Std. Error z value Pr(&gt;|z|)
## (Intercept)    71.312  14650.124   0.005    0.996
## wt             -4.005      2.956  -1.355    0.175
## cyl            -9.866   2441.687  -0.004    0.997
## 
## (Dispersion parameter for binomial family taken to be 1)
## 
##     Null deviance: 43.860  on 31  degrees of freedom
## Residual deviance:  7.199  on 29  degrees of freedom
## AIC: 13.199
## 
## Number of Fisher Scoring iterations: 20
</code></pre>

<pre><code class="r">anova(myModel, test=&quot;Chisq&quot;)
</code></pre>

<pre><code>## Analysis of Deviance Table
## 
## Model: binomial, link: logit
## 
## Response: mpgWin
## 
## Terms added sequentially (first to last)
## 
## 
##      Df Deviance Resid. Df Resid. Dev  Pr(&gt;Chi)    
## NULL                    31     43.860              
## wt    1  30.1298        30     13.730 4.041e-08 ***
## cyl   1   6.5313        29      7.199    0.0106 *  
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
</code></pre>

<pre><code class="r">myFitted &lt;- predict(myModel, newdata=myMulti, type=&quot;response&quot;)
myFitted &lt;- ifelse(myFitted&gt;0.5,1,0)

logitSens &lt;- sum(myFitted*myMulti$mpgWin)/sum(myMulti$mpgWin)
logitSpec &lt;- sum((1-myFitted)*(1-myMulti$mpgWin))/sum(1-myMulti$mpgWin)
logitAll &lt;- sum(myFitted == myMulti$mpgWin)/length(myMulti$mpgWin)

print(paste0(&quot;This logit has specificity &quot;,round(logitSpec,3),&quot; and sensitivity &quot;,
             round(logitSens,3),&quot; for total percentage &quot;,round(logitAll,3)
             )
      )
</code></pre>

<pre><code>## [1] &quot;This logit has specificity 0.944 and sensitivity 0.929 for total percentage 0.938&quot;
</code></pre>

<p>Given the friendly inputs, the logit does quite well with the predictions.  </p>

<h2>Module 5: Analysis of Variance (ANOVA)</h2>

<p>ANOVA means ANalysis Of VAriance and is a means for assessing whether multiple groups all come from the same population.  The primary idea is to compare variance between groups and variance within groups.  An advantage of ANOVA vs. multiple t-tests is that ANOVA keeps Familywise Error Rate (FEWR) at alpha while multiple t-tests require alpha correction to avoid high rates of false detection.  </p>

<p>####<em>Hypotheses, test statistics, calculations, assumptions</em>  </p>

<ul>
<li>Ho is that all groups are from the same population (loosely, have the same means)<br/></li>
<li>Ha is that one or more of the groups are from a different population (loosely have different means)<br/></li>
<li>Test Statistic F = MSBetween / MSWithin, df1=(g-1), df2=(n-g)<br/></li>
<li>Definition of n is number of total observations and definition of g is total number of groups<br/></li>
<li>Broadly, Ho reduces to F=1 and Ha is that F&gt;1<br/></li>
</ul>

<p>The calculation of the key ANOVA statistics is very similar to (and highly related to) multiple regression.  For example, the key metrics come from:  </p>

<ul>
<li>Within each group k, calculate the group mean y-bar(k)<br/></li>
<li>Across groups, calculate the grand mean y-bar-grand<br/></li>
<li>For each group k, SSWithin(k) = sum-over-i-of ( y(i) - y-bar(k) )<sup>2</sup><br/></li>
<li>SSWithin = sum-over-all-groups of SSWithin(k)<br/></li>
<li>MSWithin = SSWithin / (n-g) where n is total observations and g is total groups<br/></li>
<li>SSBetween = sum-over-all-groups-of ( n-group * (y-bar-group - y-bar-grand)<sup>2</sup> )<br/></li>
<li>MSBetween = SSBetween / (g-1) where g is the number of groups<br/></li>
</ul>

<p>The assumptions for ANOVA are broadly the same as for multiple regression.  In partiuclar, look at:  </p>

<ul>
<li>Independence of observations &ndash; if dependenet by design, need to use &ldquo;repeated measures ANOVA&rdquo;<br/></li>
<li>Normally distributed data (though robust to violations) &ndash; prefer n &gt;= 10, otherwise go non-parametric<br/></li>
<li>Homogeneity of variances within groups (though robust and generally OK if maxSD &lt;= 2*minSD)<br/></li>
</ul>

<p>####<em>Post-hoc t-tests</em><br/>
If and only if ANOVA comes back significant, post-hoc t-tests can be run.  There is a need to decide on how strictly to treat alpha in this case, recalling that ANOVA already restricted the overall model to alpha.  So, we know something is significantly different and need to decide how strict we will be in allowing post-hoc Type 1 errors in identifying those something.  </p>

<p>One approach is to use Fisher Least Significant Differences.  This approach uses the pooled standard error available from the ANOVA as follows:  </p>

<ul>
<li>Suppose we will conmpare groups j and k which have means y-bar-j and y-bar-k with counts nj and nk<br/></li>
<li>SE = sqrt( SSWithin / (n-g) ) * sqrt( 1/nj + 1/nk )<br/></li>
<li>This reduces to SE = sqrt( MSWithin )  * sqrt( 1/nj + 1/nk )<br/></li>
<li>If the groups are j and k, t = (y-bar-j minus y-bar-k) / SE, df=(n-g)<br/></li>
<li>CI = (y-bar-j minus y-bar-k) +/- critical-t * SE, df=(n-g)<br/></li>
</ul>

<p>Other approaches try to make some adjustments for FamilyWise Error Rate (FWER).  These include Bonferroni (divide alpha by the number of post-hoc comparisons) or Tukey&#39;s HSD (tries to keep FWER around alpha).  </p>

<p>The example below is borrowed liberally from seperate code I wrote to test ANOVA (see QuickLookANOVA_v001.Rmd for a more thorough explanation of the code).  </p>

<pre><code class="r">dummyData &lt;- data.frame(groupA=c(12,12,16,17,18), groupB=c(22,24,25,26,28), groupC=c(6,8,9,12,15))
boxplot(dummyData)
</code></pre>

<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-17"/></p>

<pre><code class="r">sampleStats &lt;- data.frame(means=rep(0,ncol(dummyData)),stdevs=rep(0,ncol(dummyData)))

for (intCtr in 1:ncol(dummyData)) {
    sampleStats$means[intCtr] &lt;- mean(dummyData[,intCtr])
    sampleStats$stdevs[intCtr] &lt;- sd(dummyData[,intCtr])
}

rownames(sampleStats) &lt;- names(dummyData)

print(&quot;Means and Standard Deviations&quot;)
</code></pre>

<pre><code>## [1] &quot;Means and Standard Deviations&quot;
</code></pre>

<pre><code class="r">sampleStats
</code></pre>

<pre><code>##        means   stdevs
## groupA    15 2.828427
## groupB    25 2.236068
## groupC    10 3.535534
</code></pre>

<pre><code class="r">summary(dummyData)
</code></pre>

<pre><code>##      groupA       groupB       groupC  
##  Min.   :12   Min.   :22   Min.   : 6  
##  1st Qu.:12   1st Qu.:24   1st Qu.: 8  
##  Median :16   Median :25   Median : 9  
##  Mean   :15   Mean   :25   Mean   :10  
##  3rd Qu.:17   3rd Qu.:26   3rd Qu.:12  
##  Max.   :18   Max.   :28   Max.   :15
</code></pre>

<pre><code class="r">## Calculate MSWithin
ssWithinGroups &lt;- rep(0,ncol(dummyData))

for (intCtr in 1:ncol(dummyData)) {
    for (intCtr2 in 1:nrow(dummyData)) {
        ssWithinGroups[intCtr] &lt;- ssWithinGroups[intCtr] + 
                                  (dummyData[intCtr2,intCtr] - mean(dummyData[,intCtr]))^2
    }
}

ssWithinGroups
</code></pre>

<pre><code>## [1] 32 20 50
</code></pre>

<pre><code class="r">dfWithin &lt;- ncol(dummyData) * nrow(dummyData) - ncol(dummyData)
msWithin &lt;- sum(ssWithinGroups) / dfWithin
print(paste0(&quot;MS Within: &quot;,msWithin,&quot; with df=&quot;,dfWithin))
</code></pre>

<pre><code>## [1] &quot;MS Within: 8.5 with df=12&quot;
</code></pre>

<pre><code class="r">## Calculate MSBetween
ssBetweenGroups &lt;- rep(0,ncol(dummyData))
grandMean &lt;- mean(as.matrix(dummyData))

for (intCtr in 1:ncol(dummyData)) {
    ssBetweenGroups[intCtr] &lt;- length(dummyData[,intCtr]) * (mean(dummyData[,intCtr]) - grandMean)^2
}

ssBetweenGroups
</code></pre>

<pre><code>## [1]  13.88889 347.22222 222.22222
</code></pre>

<pre><code class="r">dfBetween &lt;- ncol(dummyData) - 1
msBetween &lt;- sum(ssBetweenGroups) / dfBetween
print(paste0(&quot;MS Between: &quot;,round(msBetween,2),&quot; with df=&quot;,dfBetween))
</code></pre>

<pre><code>## [1] &quot;MS Between: 291.67 with df=2&quot;
</code></pre>

<pre><code class="r">myFStat &lt;- msBetween / msWithin
myPValue &lt;- pf(myFStat,df1=msBetween,df2=msWithin,lower.tail=FALSE)

print(paste0(&quot;F-statistic: &quot;,round(myFStat,2),&quot; with df1=&quot;,dfBetween,&quot; and df2=&quot;,dfWithin))
</code></pre>

<pre><code>## [1] &quot;F-statistic: 34.31 with df1=2 and df2=12&quot;
</code></pre>

<pre><code class="r">print(paste0(&quot;Relevant p-value is: &quot;,round(myPValue,4)))
</code></pre>

<pre><code>## [1] &quot;Relevant p-value is: 0&quot;
</code></pre>

<pre><code class="r">nCompare &lt;- 0.5 * (ncol(dummyData) * (ncol(dummyData)-1))

myFisherLSD &lt;- data.frame(compType=rep(&quot;&quot;,nCompare),diffLow=rep(0,nCompare),diffHigh=rep(0,nCompare),
                          stringsAsFactors = FALSE)

## Run for alpha=0.05 two-sided and df=dfWithin
tCritical &lt;- qt(0.025,df=dfWithin,lower.tail=FALSE)

nCompare &lt;- 1 ## Recycling the variable

for (intCtr in 1:(ncol(dummyData)-1)) {
    for (intCtr2 in (intCtr+1):ncol(dummyData)) {
        myFisherLSD$compType[nCompare] &lt;- paste0(names(dummyData)[intCtr],&quot; vs. &quot;,names(dummyData)[intCtr2])

        diffMean &lt;- mean(dummyData[,intCtr]) - mean(dummyData[,intCtr2])
        mySE &lt;- sqrt(msWithin) * sqrt(1/length(dummyData[,intCtr]) + 1/length(dummyData[,intCtr2]))

        myFisherLSD$diffLow[nCompare] &lt;- diffMean - tCritical*mySE
        myFisherLSD$diffHigh[nCompare] &lt;- diffMean + tCritical*mySE

        nCompare &lt;- nCompare + 1
    }
}

print(&quot;Below are the 95% hand-calculated CI for differences in mean using Fisher LSD&quot;)
</code></pre>

<pre><code>## [1] &quot;Below are the 95% hand-calculated CI for differences in mean using Fisher LSD&quot;
</code></pre>

<pre><code class="r">myFisherLSD
</code></pre>

<pre><code>##            compType     diffLow  diffHigh
## 1 groupA vs. groupB -14.0175323 -5.982468
## 2 groupA vs. groupC   0.9824677  9.017532
## 3 groupB vs. groupC  10.9824677 19.017532
</code></pre>

<pre><code class="r">myFactorFrame &lt;- data.frame(keyGroup=rep(&quot;&quot;,nrow(dummyData)*ncol(dummyData)),
                            indValue=rep(0,nrow(dummyData)*ncol(dummyData)),
                            stringsAsFactors = FALSE
                            )

nCompare &lt;- 1 ## Reccylcing the variable

for (intCtr in 1:ncol(dummyData)) {
    for (intCtr2 in 1:nrow(dummyData)) {
        myFactorFrame$keyGroup[nCompare] &lt;- names(dummyData)[intCtr]
        myFactorFrame$indValue[nCompare] &lt;- dummyData[intCtr2,intCtr]
        nCompare &lt;- nCompare + 1
    }
}

myFactorFrame
</code></pre>

<pre><code>##    keyGroup indValue
## 1    groupA       12
## 2    groupA       12
## 3    groupA       16
## 4    groupA       17
## 5    groupA       18
## 6    groupB       22
## 7    groupB       24
## 8    groupB       25
## 9    groupB       26
## 10   groupB       28
## 11   groupC        6
## 12   groupC        8
## 13   groupC        9
## 14   groupC       12
## 15   groupC       15
</code></pre>

<pre><code class="r">myFactorFrame$aovFactor &lt;- factor(myFactorFrame$keyGroup,levels=c(&quot;groupC&quot;,&quot;groupA&quot;,&quot;groupB&quot;))
aovFromR &lt;- aov(indValue ~ aovFactor , data=myFactorFrame)
summary(aovFromR)
</code></pre>

<pre><code>##             Df Sum Sq Mean Sq F value   Pr(&gt;F)    
## aovFactor    2  583.3   291.7   34.31 1.09e-05 ***
## Residuals   12  102.0     8.5                     
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
</code></pre>

<pre><code class="r">confint(aovFromR)
</code></pre>

<pre><code>##                      2.5 %    97.5 %
## (Intercept)      7.1591756 12.840824
## aovFactorgroupA  0.9824677  9.017532
## aovFactorgroupB 10.9824677 19.017532
</code></pre>

<pre><code class="r">## Run the Tukey HSD
TukeyHSD(aovFromR)
</code></pre>

<pre><code>##   Tukey multiple comparisons of means
##     95% family-wise confidence level
## 
## Fit: aov(formula = indValue ~ aovFactor, data = myFactorFrame)
## 
## $aovFactor
##               diff         lwr       upr     p adj
## groupA-groupC    5  0.08070249  9.919298 0.0462914
## groupB-groupC   15 10.08070249 19.919298 0.0000088
## groupB-groupA   10  5.08070249 14.919298 0.0004187
</code></pre>

<pre><code class="r">## Run standard pairwise t-tests
pairwise.t.test(x=myFactorFrame$indValue , g=myFactorFrame$keyGroup , p.adjust.method = &quot;none&quot;)
</code></pre>

<pre><code>## 
##  Pairwise comparisons using t tests with pooled SD 
## 
## data:  myFactorFrame$indValue and myFactorFrame$keyGroup 
## 
##        groupA  groupB 
## groupB 0.00015 -      
## groupC 0.01890 3.2e-06
## 
## P value adjustment method: none
</code></pre>

<pre><code class="r">## Run Bonferroni pairwise t-tests
pairwise.t.test(x=myFactorFrame$indValue , g=myFactorFrame$keyGroup , p.adjust.method = &quot;bonferroni&quot;)
</code></pre>

<pre><code>## 
##  Pairwise comparisons using t tests with pooled SD 
## 
## data:  myFactorFrame$indValue and myFactorFrame$keyGroup 
## 
##        groupA  groupB 
## groupB 0.00046 -      
## groupC 0.05669 9.5e-06
## 
## P value adjustment method: bonferroni
</code></pre>

<pre><code class="r">## Run Holm pairwise t-tests
pairwise.t.test(x=myFactorFrame$indValue , g=myFactorFrame$keyGroup , p.adjust.method = &quot;holm&quot;)
</code></pre>

<pre><code>## 
##  Pairwise comparisons using t tests with pooled SD 
## 
## data:  myFactorFrame$indValue and myFactorFrame$keyGroup 
## 
##        groupA  groupB 
## groupB 0.00031 -      
## groupC 0.01890 9.5e-06
## 
## P value adjustment method: holm
</code></pre>

<p>The hand calculations match the aov outputs observed from R.  The post-hoc confidence intervals vary depending on the metric that we choose to use.  </p>

<p>####<em>ANOVA and Multiple Regression</em><br/>
Further, ANOVA is a very close parallel to multiple regression.  </p>

<ul>
<li>MSResidual from regression will be MSWithin (within group variance) in ANOVA<br/></li>
<li>MSRegression from regression will be MSBetween (between group variance) in ANOVA<br/></li>
<li>F = MSRegression / MSResidual from regression will match F = MSBetween / MSWithin from ANOVA<br/></li>
<li>p-value is pf(F, df1=(g-1), df2=(n-g), lower.tail=FALSE) in either case<br/></li>
</ul>

<pre><code class="r">myFactorFrame$dummyA &lt;- ifelse(myFactorFrame$keyGroup==&quot;groupA&quot;,1,0)
myFactorFrame$dummyB &lt;- ifelse(myFactorFrame$keyGroup==&quot;groupB&quot;,1,0)

myLMDummy &lt;- lm(indValue ~ dummyA + dummyB, data=myFactorFrame)
summary(myLMDummy)
</code></pre>

<pre><code>## 
## Call:
## lm(formula = indValue ~ dummyA + dummyB, data = myFactorFrame)
## 
## Residuals:
##    Min     1Q Median     3Q    Max 
##   -4.0   -2.5    0.0    2.0    5.0 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(&gt;|t|)    
## (Intercept)   10.000      1.304   7.670 5.77e-06 ***
## dummyA         5.000      1.844   2.712   0.0189 *  
## dummyB        15.000      1.844   8.135 3.17e-06 ***
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Residual standard error: 2.915 on 12 degrees of freedom
## Multiple R-squared:  0.8512, Adjusted R-squared:  0.8264 
## F-statistic: 34.31 on 2 and 12 DF,  p-value: 1.087e-05
</code></pre>

<pre><code class="r">confint(myLMDummy)
</code></pre>

<pre><code>##                  2.5 %    97.5 %
## (Intercept)  7.1591756 12.840824
## dummyA       0.9824677  9.017532
## dummyB      10.9824677 19.017532
</code></pre>

<p>As expected, the F-statistic is identical in the multivariate regression with dummy (factor) variables.  Further, the confidence intervals match those provided by aov().  </p>

<p>####<em>Factorial ANOVA</em><br/>
There is no particular reason that there needs to be just one factor variable.  Factorial ANOVA is run when you have two or more factors and one depedent variable.  An example would be when you have a 2x2x3 experiment frame and want to understand the potential differences.  </p>

<p>As a first approach, you can always collapse down to a single dimension and run ANOVA to look for the &ldquo;main effect&rdquo; of that specific variable.  </p>

<p>There can also be value to looking for the interaction effects.  Broadly speaking:</p>

<ul>
<li>1 dependent, 1 independent - one-way ANOVA<br/></li>
<li>1 dependent, 2+ independent - factorial ANOVA<br/></li>
<li>2+ dependent, 1 independent - Multiple ANOVAs<br/></li>
<li>2+ dependent, 2+ independent - MANOVA<br/></li>
</ul>

<p>Suppose for this example that you have three levels on variable A and two levels on variables B and have the mean, standard deviation, and N for each of the AxB buckets.  You also have the marginals for A and B.  </p>

<p>The key terms are then (Within=Overall, DueA/DueB on marginals, DueAB on joints):  </p>

<ul>
<li>SSWithin = sum-over-k-of ( (nk-1) * sdk<sup>2</sup> ), dfWithin = N - g [N total observations in g groups]<br/></li>
<li>SSDueA = sum-over-j-of ( nj * (mean-in-j - grand-mean)<sup>2</sup> ), df = g(a) - 1 [g(a)=groups of a]<br/></li>
<li>SSDueB = sum-over-m-of ( nm * (mean-in-m - grand-mean)<sup>2</sup> ), df = g(b) - 1 [g(b)=groups of b]<br/></li>
<li>SSDueAB = sum-over-z-of ( nz * (mean-in-z - row-mean - col-mean + grand-mean)<sup>2</sup> ), df=(g(a) - 1) * (g(b) - 1), where g(a) is the number of groups of type A and g(b) is the number of groups of type B.<br/></li>
</ul>

<p>That is confusing!  An example may be helpful.  </p>

<pre><code class="r">## Create an example grid with n, mu, and sd
factFrame &lt;- data.frame(typeA=c(rep(&quot;1&quot;,3),rep(&quot;2&quot;,3),rep(&quot;3&quot;,3),rep(&quot;Total&quot;,3)),
                        typeB=rep(c(&quot;1&quot;,&quot;2&quot;,&quot;Total&quot;),4),
                        groupN=c(20,22,42,15,32,47,18,21,39,53,75,128),
                        groupMean=c(5.35,5.73,5.55,5,5.34,5.23,5.72,5.10,5.38,5.38,5.39,5.38),
                        groupSD=c(1.21,1.17,1.19,1.14,1.10,1.12,1.06,1.15,1.11,1.13,1.14,1.14)
                        )

withinFrame &lt;- subset(factFrame, typeA != &quot;Total&quot; &amp; typeB != &quot;Total&quot;)
gA &lt;- sum(table(withinFrame$typeA)&gt;0)
gB &lt;- sum(table(withinFrame$typeB)&gt;0)
overallN &lt;- sum(withinFrame$groupN)
grandMean &lt;- sum(withinFrame$groupMean * withinFrame$groupN) / overallN

ssWithin &lt;- sum( (withinFrame$groupN - 1) * withinFrame$groupSD^2 )
dfWithin &lt;- overallN - gA * gB

dueAFrame &lt;- subset(factFrame, typeA != &quot;Total&quot; &amp; typeB == &quot;Total&quot;)
ssDueA &lt;- sum( dueAFrame$groupN * ( dueAFrame$groupMean - grandMean )^2 )
dfDueA &lt;- gA - 1

dueBFrame &lt;- subset(factFrame, typeA == &quot;Total&quot; &amp; typeB != &quot;Total&quot;)
ssDueB &lt;- sum( dueBFrame$groupN * ( dueBFrame$groupMean - grandMean )^2 )
dfDueB &lt;- gB - 1

dueABFrame &lt;- withinFrame
dueABFrame$meanA &lt;- dueAFrame[match(withinFrame$typeA,dueAFrame$typeA),&quot;groupMean&quot;]
dueABFrame$meanB &lt;- dueBFrame[match(withinFrame$typeB,dueBFrame$typeB),&quot;groupMean&quot;]
ssDueAB &lt;- sum( dueABFrame$groupN * ( dueABFrame$groupMean - dueABFrame$meanA - dueABFrame$meanB + grandMean)^2 )
dfDueAB &lt;- (gA - 1) * (gB - 1)

fDueA &lt;- (ssDueA / dfDueA) / (ssWithin / dfWithin)
pDueA &lt;- pf(fDueA, dfDueA, dfWithin, lower.tail=FALSE)
dueAFrame
</code></pre>

<pre><code>##   typeA typeB groupN groupMean groupSD
## 3     1 Total     42      5.55    1.19
## 6     2 Total     47      5.23    1.12
## 9     3 Total     39      5.38    1.11
</code></pre>

<pre><code class="r">print(paste0(&quot;Due A Marginal: F=&quot;,round(fDueA,2),&quot; with p=&quot;,round(pDueA,4)))
</code></pre>

<pre><code>## [1] &quot;Due A Marginal: F=0.88 with p=0.4182&quot;
</code></pre>

<pre><code class="r">fDueB &lt;- (ssDueB / dfDueB) / (ssWithin / dfWithin)
pDueB &lt;- pf(fDueB, dfDueB, dfWithin, lower.tail=FALSE)
dueBFrame
</code></pre>

<pre><code>##    typeA typeB groupN groupMean groupSD
## 10 Total     1     53      5.38    1.13
## 11 Total     2     75      5.39    1.14
</code></pre>

<pre><code class="r">print(paste0(&quot;Due B Marginal: F=&quot;,round(fDueB,2),&quot; with p=&quot;,round(pDueB,4)))
</code></pre>

<pre><code>## [1] &quot;Due B Marginal: F=0 with p=0.9542&quot;
</code></pre>

<pre><code class="r">fDueAB &lt;- (ssDueAB / dfDueAB) / (ssWithin / dfWithin)
pDueAB &lt;- pf(fDueAB, dfDueAB, dfWithin, lower.tail=FALSE)
dueABFrame
</code></pre>

<pre><code>##   typeA typeB groupN groupMean groupSD meanA meanB
## 1     1     1     20      5.35    1.21  5.55  5.38
## 2     1     2     22      5.73    1.17  5.55  5.39
## 4     2     1     15      5.00    1.14  5.23  5.38
## 5     2     2     32      5.34    1.10  5.23  5.39
## 7     3     1     18      5.72    1.06  5.38  5.38
## 8     3     2     21      5.10    1.15  5.38  5.39
</code></pre>

<pre><code class="r">print(paste0(&quot;Due AB Marginal: F=&quot;,round(fDueAB,2),&quot; with p=&quot;,round(pDueAB,4)))
</code></pre>

<pre><code>## [1] &quot;Due AB Marginal: F=2.47 with p=0.0887&quot;
</code></pre>

<pre><code class="r">## An example from the Tooth Growth Data -- much easier to use R!
data(ToothGrowth)
summary(aov(len ~ dose * supp, data=ToothGrowth))
</code></pre>

<pre><code>##             Df Sum Sq Mean Sq F value   Pr(&gt;F)    
## dose         1 2224.3  2224.3 133.415  &lt; 2e-16 ***
## supp         1  205.3   205.3  12.317 0.000894 ***
## dose:supp    1   88.9    88.9   5.333 0.024631 *  
## Residuals   56  933.6    16.7                     
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
</code></pre>

<p>So, while this can be calculated by hand, if you have the raw data, then it is a lot easier to use the interaction term for aov() in R.  </p>

<h2>Module 6: Nonparametric tests</h2>

<p>Non-parametric tests allow for drawing inferences even when the population paremeters are unknown or known to violate one or more conditions for the associated parametric test.  Broadly, the non-parametric tests are often comparable to a related parametric test.  </p>

<p>Common reasons for using a nonparametric test include:  </p>

<ul>
<li>Requires fewer assumptions than a parametric test<br/></li>
<li>Allows for ordinal data, such as ranking on a scale of 1-5<br/></li>
<li>Frequently robust to violations of assumptions (tend not to be terribly wrong)<br/></li>
<li>Manages small sample sizes better<br/></li>
</ul>

<p>The tradeoff is that while nonparametric tests tend to be more robust, parametric tests tend to have better power.  As and when sample sizes and assumptions allow, the parametric test is preferred.  </p>

<p>####<em>Sign test</em><br/>
The non-parametric sign test is the rough equivalent to the one-sided t-test.  It is typically used for sample sized smaller than 30-35, with the t-test (assumptions of normality) becoming good enough beyond that.  </p>

<p>Essentially, this is a voting system which is then evaluated based on the associated binomial distribution.  For example, suppose you wonder whether candy A or candy B tastes better.  You would gather in some votes, ignore the ties, and then see what the binomial distribution says.  </p>

<p>Ho: P(x &gt; y) = p, frequently, though not necessarily, 50%<br/>
Ha: P(x &gt; y) &lt;&gt; p, frequently, though not necessarily, one-sided<br/>
test statisttic: binomial distribution of w wins in n trials  </p>

<p>Suppose that we sample from a distribution that has 60% favor A, 10% favor neither, and 30% favor B.  We take 20 pulls from the population and run the sign test.  See for example:  </p>

<pre><code class="r">set.seed(0316160710)

randPulls &lt;- runif(20,0,1)
nWin &lt;- sum(randPulls &lt;= 0.6)
nLose &lt;- sum(randPulls &gt;= 0.7)
nTie &lt;- sum(randPulls &gt; 0.6 &amp; randPulls &lt; 0.7)

print(paste0(&quot;The sample has &quot;,nWin,&quot; wins, &quot;,nLose,&quot; losses, and &quot;,nTie,&quot; ties&quot;))
</code></pre>

<pre><code>## [1] &quot;The sample has 13 wins, 5 losses, and 2 ties&quot;
</code></pre>

<pre><code class="r">## Interested only in the wins and losses and the binomial test
binTest &lt;- binom.test(x=nWin, n=(nWin+nLose), p=0.5, alternative=&quot;two.sided&quot;)
binTest ## fail to reject due to p=0.096
</code></pre>

<pre><code>## 
##  Exact binomial test
## 
## data:  nWin and (nWin + nLose)
## number of successes = 13, number of trials = 18, p-value = 0.09625
## alternative hypothesis: true probability of success is not equal to 0.5
## 95 percent confidence interval:
##  0.4651980 0.9030508
## sample estimates:
## probability of success 
##              0.7222222
</code></pre>

<pre><code class="r">## Can be run as one-sided
binTest &lt;- binom.test(x=nWin, n=(nWin+nLose), p=0.5, alternative=&quot;greater&quot;)
binTest ## reject based on p=0.048
</code></pre>

<pre><code>## 
##  Exact binomial test
## 
## data:  nWin and (nWin + nLose)
## number of successes = 13, number of trials = 18, p-value = 0.04813
## alternative hypothesis: true probability of success is greater than 0.5
## 95 percent confidence interval:
##  0.5021718 1.0000000
## sample estimates:
## probability of success 
##              0.7222222
</code></pre>

<pre><code class="r">## The key cutoffs
qbinom(0.95,18,0.5) + 1  ## Cutoff for one-sided with 18 tries
</code></pre>

<pre><code>## [1] 13
</code></pre>

<pre><code class="r">qbinom(0.975,18,0.5) + 1  ## Cutoff for two-sided with 18 tries
</code></pre>

<pre><code>## [1] 14
</code></pre>

<p>####<em>One-sample Wilcoxon signed ranks</em><br/>
This is roughly the equivalent to the one-sample t-test, and it expands on the sign test by treating different magnitudes of responses as having meaning.  The test looks at the median for its central tendency, and requires only that the sampling by independent and from a roughly symmetric population.  </p>

<p>This test frequently arises when you ask people to rate two items on a scale of 1-5 and want to test whether the first or second item is more popular.  The sign test would allow you to do this also, but the signed ranks test has the advantage of seeing 4-1 as different than 3-2 (where the sign test would see both as &ldquo;win&rdquo;).</p>

<p>The table of paired responses is lined up, and any ties are deleted prior to running the test.  Next, new columns are created for 1) absolute value of score difference, and 2) sign of score difference.  The absolute value of score differences is ranked - IMPORTANT that everyone with a tied absolute score difference be given the average rank of their tied group - and the ranks are summed for both the positive (win) and negative (lose) categories.  A lookup table can then give you P(W &gt; w), and care should be taken that you use the appropriate alpha depending on one-sided vs. two-sided.  </p>

<p>Ho: The medians of both groups are the same<br/>
Ha: The medians of the groups are different (one-sided or two-sided as appropriate)<br/>
Test statistic: W, the sum of ranks for the positive group  </p>

<p>Suppose for example that you ask 15 people to each rate two pastries.  See below for R code:</p>

<pre><code class="r">v1 &lt;- round(5*runif(15,0,1),0)
v2 &lt;- round(5*runif(15,0,1)^2,0)

myFrame &lt;- data.frame(v1=v1, v2=v2, absdiff=abs(v1-v2), type=sign(v1-v2), absRank=0)
myFrame
</code></pre>

<pre><code>##    v1 v2 absdiff type absRank
## 1   4  0       4    1       0
## 2   1  2       1   -1       0
## 3   1  1       0    0       0
## 4   3  1       2    1       0
## 5   3  2       1    1       0
## 6   4  2       2    1       0
## 7   0  0       0    0       0
## 8   4  0       4    1       0
## 9   4  1       3    1       0
## 10  3  4       1   -1       0
## 11  4  2       2    1       0
## 12  1  1       0    0       0
## 13  1  2       1   -1       0
## 14  5  2       3    1       0
## 15  3  3       0    0       0
</code></pre>

<pre><code class="r">## Filter out ties
myFrame &lt;- myFrame[myFrame$absdiff!=0,]

## Rank the absolute values
myFrame$absRank &lt;- rank(myFrame$absdiff,ties.method=&quot;average&quot;)
myFrame
</code></pre>

<pre><code>##    v1 v2 absdiff type absRank
## 1   4  0       4    1    10.5
## 2   1  2       1   -1     2.5
## 4   3  1       2    1     6.0
## 5   3  2       1    1     2.5
## 6   4  2       2    1     6.0
## 8   4  0       4    1    10.5
## 9   4  1       3    1     8.5
## 10  3  4       1   -1     2.5
## 11  4  2       2    1     6.0
## 13  1  2       1   -1     2.5
## 14  5  2       3    1     8.5
</code></pre>

<pre><code class="r">## Calculate test statistic
testW &lt;- sum(subset(myFrame,type==1)$absRank)
nW &lt;- length(subset(myFrame,type==1)$absRank)
testL &lt;- sum(subset(myFrame,type==-1)$absRank)
nL &lt;- length(subset(myFrame,type==-1)$absRank)

print(paste0(&quot;The positive ranks sum to &quot;,testW,&quot; of &quot;,testW+testL,
             &quot; with &quot;,nW,&quot; positive of &quot;,nW+nL,&quot; total&quot;
             )
      )
</code></pre>

<pre><code>## [1] &quot;The positive ranks sum to 58.5 of 66 with 8 positive of 11 total&quot;
</code></pre>

<pre><code class="r">## Wilcoxon signed rank test (one-sided)
psignrank(floor(testW),(nW+nL),lower.tail=FALSE) ## 0.5s not in psignrank
</code></pre>

<pre><code>## [1] 0.009277344
</code></pre>

<pre><code class="r">## Standard binomial test
binTest &lt;- binom.test(x=nW, n=(nW+nL), p=0.5, alternative=&quot;greater&quot;)
binTest
</code></pre>

<pre><code>## 
##  Exact binomial test
## 
## data:  nW and (nW + nL)
## number of successes = 8, number of trials = 11, p-value = 0.1133
## alternative hypothesis: true probability of success is greater than 0.5
## 95 percent confidence interval:
##  0.4356258 1.0000000
## sample estimates:
## probability of success 
##              0.7272727
</code></pre>

<p>Note in this case how the signed-rank test easily spots the difference in median while the sign (binomial) test cannot draw the same inference.  This is because while v2 has chances to beat v1, they will tend to be small ones.  On the other hand, v1 is both more likely to beat v2 and also more likely to win big.</p>

<p>The Wilcoxon signed rank test can also be used by plugging the theoretical median in to column 2 if you have Ho: median=m.  </p>

<p>####<em>Two-samples Wilcoxon / Mann-Whitney</em><br/>
The Wilcoxon (or Mann-Whitney) test is the nonparametric version of comparing differences in means for two samples.  The nonparamentric version looks at mean ranks, similar to the signed-rank test.  </p>

<p>The Wilcoxon test would be created by taking the data for type A and type B, combining it as appropriate and running the below:  </p>

<ul>
<li>Ho: mean rank sales in A and B are equal<br/></li>
<li>Ha: mean rank sales in A and B are unequal (usually two-sided, but could be one-sided)<br/></li>
<li>Test statistic Wx is the sum of ranks of one of the groups<br/></li>
<li>Assign ranks to the elements of the combined data, giving tied elements the average rank<br/></li>
<li>Then, sum the ranks for both A and B<br/></li>
<li>Look up the critical values in a table, and assess significance<br/></li>
</ul>

<p>Typically, if group sizes are greater than 10, you have enough data for the z-test.  Suppose you have:  </p>

<ul>
<li>Ranks x1, x2, &hellip; , xm<br/></li>
<li>Ranks y1, y2, &hellip; , yn<br/></li>
<li>Expected rank sum for X will be 0.5 * m * (m + n + 1), or substitute in N = m + n<br/></li>
<li>Expected standard deviation of rank sum is sqrt( m * n * (m + n + 1) / 12 )<br/></li>
<li>(Wx - mu(Wx)) / sigma(Wx) will roughly follow a z-distribution<br/></li>
</ul>

<p>The Wilcoxon test is often the most suitable test for measuring central tendency.  You can use oridnal or numeric data, it is almost as powerful as the parametric test, and requires only indpendence of data.  </p>

<p>See below for an example:  </p>

<pre><code class="r">set.seed(0316161754)
rand1 &lt;- rnorm(20,mean=1)
rand2 &lt;- rnorm(15,mean=1.5)

randAll &lt;- rbind(data.frame(rand=rand1,type=&quot;A&quot;),
                 data.frame(rand=rand2,type=&quot;B&quot;)
                 )
randAll$rank &lt;- rank(randAll$rand, ties.method=&quot;average&quot;)

m &lt;- length(rand1)
n &lt;- length(rand2)

expMuW &lt;- 0.5 * m * (m + n + 1)
expSigmaW &lt;- sqrt( m * n * (m + n + 1) / 12 )

testW &lt;- sum(randAll[randAll$type==&quot;A&quot;,]$rank)

zStat &lt;- (testW - expMuW) / expSigmaW
pStat &lt;- 1 - 2 * abs(pnorm(zStat) - 0.5)

print(paste0(&quot;Rank sum for A is &quot;,testW,&quot; where mean is &quot;,expMuW,
             &quot; and sigma is &quot;,expSigmaW,&quot; for z=&quot;,round(zStat,2),
             &quot; with two-tailed p=&quot;,round(pStat,4)
             )
      )
</code></pre>

<pre><code>## [1] &quot;Rank sum for A is 280 where mean is 360 and sigma is 30 for z=-2.67 with two-tailed p=0.0077&quot;
</code></pre>

<pre><code class="r">wilcox.test(rand1, rand2,correct=FALSE)
</code></pre>

<pre><code>## 
##  Wilcoxon rank sum test
## 
## data:  rand1 and rand2
## W = 70, p-value = 0.006848
## alternative hypothesis: true location shift is not equal to 0
</code></pre>

<p>While these tests give similar results, there are some differences since n=15 and n=20 are still a distance from CLT holding perfectly.  </p>

<p>####<em>Kruskal-Willis</em><br/>
Mean rank testing can be expanded to 3+ groups, similar to the concept with ANOVA.  The Kruskal-Willis test is the broad non-parametric equivalent of the one-way ANOVA.  </p>

<p>Ho: The groups all have the same mean rank<br/>
Ha: At least one of the groups have different mean rank<br/>
Test statistic: H with follow chi-squared df=(g-1) where g is the number of groups  </p>

<p>The general approach to the Kruskal-Willis test should be familiar:  </p>

<ol>
<li> Take all of the data and rank the observations (give average tied rank to everyone in the tied group)<br/></li>
<li> Calculate the overall mean R-bar, as well as the mean of each group, R-bar-k<br/></li>
<li> H = [ 12 / ( N * (N + 1) ) ] * sum-over-k-of nk * (R-bar-k - R-bar)<sup>2,</sup> N being total observations<br/></li>
<li> Assess H as chi-squared df=(g-1), with g being the number of groups<br/></li>
</ol>

<p>Similar to ANOVA, a significant H does not tell you how the groups differ from each other, merely that there is at least one meaningful difference.  Compared to ANOVA:  </p>

<ul>
<li>ANOVA requires normally distribiuted, non-skewed, populations with homogenous variance, using quantitative variables<br/></li>
<li>KW can use quantitative or oridnal variables, and in small-n environments, and where ANOVA assumptions fail to hold<br/></li>
</ul>

<p>See below for an example:  </p>

<pre><code class="r">fr &lt;- c(65,68,72,83,84,91,94,97)
ch &lt;- c(25,37,49,54,59,81,82)
sp &lt;- c(13,41,49,52,55,82)

myFrame &lt;- rbind(data.frame(dat=fr,type=&quot;fr&quot;), data.frame(dat=ch,type=&quot;ch&quot;),
                 data.frame(dat=sp,type=&quot;sp&quot;)
                 )

myFrame$rank = rank(myFrame$dat,ties.method=&quot;average&quot;)
myFrame
</code></pre>

<pre><code>##    dat type rank
## 1   65   fr 11.0
## 2   68   fr 12.0
## 3   72   fr 13.0
## 4   83   fr 17.0
## 5   84   fr 18.0
## 6   91   fr 19.0
## 7   94   fr 20.0
## 8   97   fr 21.0
## 9   25   ch  2.0
## 10  37   ch  3.0
## 11  49   ch  5.5
## 12  54   ch  8.0
## 13  59   ch 10.0
## 14  81   ch 14.0
## 15  82   ch 15.5
## 16  13   sp  1.0
## 17  41   sp  4.0
## 18  49   sp  5.5
## 19  52   sp  7.0
## 20  55   sp  9.0
## 21  82   sp 15.5
</code></pre>

<pre><code class="r">rBar &lt;- mean(myFrame$rank)
overallN &lt;- length(myFrame$rank)

rBarGroup &lt;- tapply(myFrame$rank,myFrame$type,FUN=mean)
rBarN &lt;- tapply(myFrame$rank,myFrame$type,FUN=length)

statH &lt;- ( sum(rBarN * (rBarGroup - rBar)^2 ) ) * 
         (12 / (overallN * (overallN + 1) ) )

print(paste0(&quot;The K-W stat is &quot;,round(statH,2),&quot; on df=&quot;,length(rBarN)-1,
             &quot; for p=&quot;,round(pchisq(statH, df=(length(rBarN)-1),lower.tail=FALSE),4)
             )
      )
</code></pre>

<pre><code>## [1] &quot;The K-W stat is 9.84 on df=2 for p=0.0073&quot;
</code></pre>

<pre><code class="r">kruskal.test(dat ~ type, data=myFrame)
</code></pre>

<pre><code>## 
##  Kruskal-Wallis rank sum test
## 
## data:  dat by type
## Kruskal-Wallis chi-squared = 9.8491, df = 2, p-value = 0.007266
</code></pre>

<p>The results of the hand calculation and the R function are very close, but not quite the same.  I am not sure what drives the very small difference in chi-squared statistic.  </p>

<p>####<em>Spearman correlation (monotonicity)</em><br/>
The Pearson correlation is the most commonly used test for linear association between two quantitative variables.  It does require that the variables be bivariate normally distributed, and is sensitive to both outliers and skew of the underlying data.  </p>

<p>The Spearman correlation meansure the monotonic association between two variables, and is especially valuable when working with ordinal variables, non-linear relationships, outliers, non-normal distributions, and small-n.  </p>

<p>The Spearman correlation (rank correlation) measure the strength of monotonic association between the data, and varies between -1 and 1 just like a regular correlation.  </p>

<p>The Spearman correlation works by assigning a rank within each of the columns of interest, then running Pearson&#39;s correlation on the ranks.  Recall that all tied values should get the group tied average rank.  </p>

<p>See below for an example:  </p>

<pre><code class="r">colA &lt;- c(3 , 4 , 4 , 5 , 7 , 7 , 10 , 12 , 13)
colB &lt;- c(2 , 3 , 4.5 , 4 , 5.4 , 5.5 , 6.5 , 6 , 6.25)

rksA &lt;- rank(colA,ties.method=&quot;average&quot;)
rksB &lt;- rank(colB,ties.method=&quot;average&quot;)

print(paste0(&quot;The Pearson correlation is &quot;,round(cor(colA,colB),3),
             &quot; with Spearman correlation of &quot;,round(cor(rksA,rksB),3)
             )
      )
</code></pre>

<pre><code>## [1] &quot;The Pearson correlation is 0.859 with Spearman correlation of 0.916&quot;
</code></pre>

<pre><code class="r">cor(colA,colB,method=&quot;pearson&quot;)
</code></pre>

<pre><code>## [1] 0.8586753
</code></pre>

<pre><code class="r">cor(colA,colB,method=&quot;spearman&quot;)
</code></pre>

<pre><code>## [1] 0.9159987
</code></pre>

<p>As expected, the correlation from method=&ldquo;spearman&rdquo; matches using default (Pearson) correlation on the ranked dataset.  </p>

<p>####<em>Runs test</em><br/>
The runs test examines the number of runs in a dataset.  This requires a means of classifying each element as one of two types.  For example, it could be Heads/Tails or Above/Below Average or Rising/Falling.  Within the data, a run is considered to occur every time there is a change from type 1 to type 2 or vice versa.  Importantly, the first element of the group is always the first run, and the first appearance of the other element is always the second run.  </p>

<p>If there are very few runs, then it suggests there is bunching of some type.  If there are very many runs, then it suggests systemic fluctuations are present.  In either case, the data are decidedly non-random.  </p>

<p>Suppose that you have some data and count the runs:  </p>

<ul>
<li>m = total elements of type 1<br/></li>
<li>n = total elements of type 2<br/></li>
<li>N = (m+n) = total elements<br/></li>
<li>runs = total number of runs<br/></li>
</ul>

<p>If you are working in the small-n (m,n less than 10) world, these are lookups against a table.  As the world gets larger, you can start to use z-tests assuming:  </p>

<ul>
<li>mu(runs) = (2 * m * n / N) + 1 where N = m+n is the total number of elements<br/></li>
<li>sigma(runs) = sqrt( (2 * m * n * (2 * m * n - N) ) / ( N<sup>2</sup> * (N - 1) ) )<br/></li>
</ul>

<p>See below for an example calculation:  </p>

<pre><code class="r">myRun &lt;- c(0,1,1,1,0,1,0,0,1,0,1,0,1,0,1,0,1,0,1,1,0,0,1)

m &lt;- sum(myRun==0)
n &lt;- sum(myRun==1)
bigN &lt;- sum(m,n)

nRuns &lt;- 1
for (intCtr in 2:bigN) {
    nRuns &lt;- nRuns + (myRun[intCtr] != myRun[intCtr-1])
}

print(paste0(&quot;There are &quot;,nRuns,&quot; runs on &quot;,bigN,&quot; elements split m=&quot;,m,&quot; and n=&quot;,n))
</code></pre>

<pre><code>## [1] &quot;There are 18 runs on 23 elements split m=11 and n=12&quot;
</code></pre>

<pre><code class="r">muRuns &lt;- (2 * m * n / bigN) + 1
sigmaRuns &lt;- sqrt( (2 * m * n * (2 * m * n - bigN) ) / 
                   ( bigN^2 * (bigN - 1) ) 
                  )
zStat &lt;- (nRuns - muRuns) / sigmaRuns
pStat &lt;- 1 - 2 * abs(pnorm(zStat) - 0.5)

print(paste0(&quot;With expected mu &quot;,round(muRuns,2),&quot; and sigma &quot;,round(sigmaRuns,2),
             &quot; , z-stat is &quot;,round(zStat,3),&quot; for two-tailed p=&quot;,round(pStat,4)
             )
      )
</code></pre>

<pre><code>## [1] &quot;With expected mu 12.48 and sigma 2.34 , z-stat is 2.362 for two-tailed p=0.0182&quot;
</code></pre>

<p>This can be handy for assessing whether or not trends observed in data are consistent with randomness.</p>

<h2>Module 7: Practical examples</h2>

<p>Below are a few practical examples that may come in handy:  </p>

<ol>
<li>Random data to hit a target mean and SD<br/></li>
<li>Dredging through multiple simulations to get significant-p for rnorm vs. rnorm<br/></li>
<li>Chebyshev&#39;s inequality recap<br/></li>
<li>Impact of paired testing (t-test)<br/></li>
<li>Impact of paired testing (prop-test)<br/></li>
<li>Factorial transforms for Fisher Exact<br/></li>
<li>Vector factorial and correlations<br/></li>
<li>Impact of Pairs on Correlation<br/></li>
<li>Post-hoc (ANOVA) group mean comparisons<br/></li>
</ol>

<p>####<em>7.01 Random data for target mean/SD</em><br/>
First, the ability to leverage the meaning of standard deviation and mean to simulate random data that hits a target mean and standard deviation for a pre-supplied N.  </p>

<pre><code class="r">## Generating random data to exactly hit a target mean and SD
genRandMuSigma &lt;- function(tgtMean, tgtSD, tgtN, nTries=100, forceInt=TRUE, forceNonNeg=TRUE) {

    if (tgtN &lt; 3) {
        stop(paste0(&quot;Cannot simulate for two or fewer values&quot;))
    }

    ## Calculate the needed SumX and SumXSq using the definition of mean and SD
    ## Mean = SUM(X) / N
    tgtSumX &lt;- tgtMean * tgtN

    ## SD = SQRT ( SUMSQ(X - Mean) / (N - 1) ) -- sample SD formula
    tgtSumXSq &lt;- (tgtN - 1) * tgtSD^2 + tgtN * tgtMean^2

    ## The routine will force the last two values to hit these targets, which can be impossible
    ## As such, it runs a loop for nTries times and then crashes out if it cannot succeed
    ## The last two values may be non-integers regardless of forceInt, but will not be imaginary
    gotSolution &lt;- FALSE

    for (intCtr in 1:nTries) {
        randVector &lt;- rep(-999, tgtN)
        randVector[1:(tgtN - 2)] &lt;- rnorm(tgtN - 2, mean=tgtMean, sd=tgtSD)

        if ( forceInt ) { 
            randVector[1:(tgtN - 2)] &lt;- round(randVector[1:(tgtN - 2)],0) 
        }

        if ( forceNonNeg ) {
            randVector[1:(tgtN - 2)] &lt;- pmax(randVector[1:(tgtN - 2)],0)             
        }

        remSum &lt;- tgtSumX - sum(randVector[1:(tgtN - 2)])
        remSumSq &lt;- tgtSumXSq - sum(randVector[1:(tgtN - 2)]^2)

        ## Consider the final two values of randVector to be a and b
        ## Then require a + b = remSum and a^2 + b^2 = remSumSq
        ## Squaring, a^2 + 2 * a * b + b^2 = remSum^2, so remSumSq + 2 * a * b = remSum^2
        ## And since b = remSum - a, then remSum^2 - remSumSq = 2 * a * (remSum - a)
        ## So, -2 * a^2 + 2 * remSum * a = (remSum^2 - remSumSq)
        ## And, a^2 - remSum * a + 0.5 * (remSum^2 - remSumSq) = 0
        ## Quadratically, a = [ remSum +/- sqrt( remSum^2 - 2*(remSum^2 - remSumSq) ) ] / 2
        ## So, a = 0.5 * ( remSum +/- sqrt ( 2 * remSumSq - remSum^2 ) )
        ## With b=remSum-a (note that the +/- for a just return v1,v2 and v2,v1 in different order)

        ## Proceed only if the outputs will be valid
        check1 &lt;- 2 * remSumSq - remSum^2 ## sqrt is a real number if this is non-negative
        check2 &lt;- remSum^2 - check1 ## the smaller of v1, v2 is negative if this is negative

        if ( check1 &gt;= 0 &amp; ( (check2 &gt;= 0 &amp; remSum &gt;= 0) | !forceNonNeg) ){
            randVector[tgtN - 1] &lt;- 0.5 * ( remSum + sqrt(check1) )
            randVector[tgtN] &lt;- 0.5 * ( remSum - sqrt(check1) )

            print(paste0(&quot;Good news, found a valid vector at try &quot;,intCtr))
            print(paste0(&quot;Mean: &quot;,mean(randVector),&quot; with SD: &quot;,sd(randVector),
                         &quot; and min: &quot;,min(randVector)
                         )
                  )

            gotSolution &lt;- TRUE
            return(randVector)
            break ## This will break out of the FOR loop
        }



    }

    if ( !gotSolution ) {
        print(&quot;Sorry, unable to generate the requested data, perhaps try again&quot;)
    }

}

randGroup1 &lt;- genRandMuSigma(tgtMean=10, tgtSD=2, tgtN=12)
</code></pre>

<pre><code>## [1] &quot;Good news, found a valid vector at try 1&quot;
## [1] &quot;Mean: 10 with SD: 2 and min: 7&quot;
</code></pre>

<pre><code class="r">round(randGroup1, 3)
</code></pre>

<pre><code>##  [1] 10.000 10.000 10.000  8.000  9.000  9.000 11.000 12.000  7.000 10.000
## [11] 14.828  9.172
</code></pre>

<pre><code class="r">randGroup2 &lt;- genRandMuSigma(tgtMean=1, tgtSD=2, tgtN=12)
</code></pre>

<pre><code>## [1] &quot;Good news, found a valid vector at try 38&quot;
## [1] &quot;Mean: 1 with SD: 2 and min: 0&quot;
</code></pre>

<pre><code class="r">round(randGroup2, 3)
</code></pre>

<pre><code>##  [1] 0.000 0.000 0.000 0.000 1.000 0.000 1.000 0.000 0.000 3.000 6.702
## [12] 0.298
</code></pre>

<pre><code class="r">randGroup3 &lt;- genRandMuSigma(tgtMean=1, tgtSD=2, tgtN=12, forceNonNeg = FALSE)
</code></pre>

<pre><code>## [1] &quot;Good news, found a valid vector at try 4&quot;
## [1] &quot;Mean: 1 with SD: 2 and min: -2&quot;
</code></pre>

<pre><code class="r">round(randGroup3, 3)
</code></pre>

<pre><code>##  [1]  2  1 -2  0  0 -1  0  2 -1  3  4  4
</code></pre>

<pre><code class="r">randGroup4 &lt;- genRandMuSigma(tgtMean=1, tgtSD=2, tgtN=12, forceInt = FALSE)
</code></pre>

<pre><code>## [1] &quot;Good news, found a valid vector at try 42&quot;
## [1] &quot;Mean: 1 with SD: 2 and min: 0&quot;
</code></pre>

<pre><code class="r">round(randGroup4, 3)
</code></pre>

<pre><code>##  [1] 1.879 0.000 0.000 0.000 0.160 0.000 0.163 1.484 0.000 0.000 6.954
## [12] 1.360
</code></pre>

<pre><code class="r">randGroup5 &lt;- genRandMuSigma(tgtMean=10, tgtSD=8, tgtN=12)
</code></pre>

<pre><code>## [1] &quot;Good news, found a valid vector at try 2&quot;
## [1] &quot;Mean: 10 with SD: 8 and min: 0&quot;
</code></pre>

<pre><code class="r">round(randGroup5, 3)
</code></pre>

<pre><code>##  [1] 11.000 14.000  3.000 14.000  0.000  4.000  9.000  6.000  2.000 12.000
## [11] 29.152 15.848
</code></pre>

<p>####<em>7.02 Random data for Bonferroni/FDR</em><br/>
Next, a function is created to show that high correlations (low p-values) will occur by chance with sufficient numbers of random trials.  This shows the risks of failing to run an appropriate correction such as Bonferroni or FDR in assessing &ldquo;is this specific finding significant&rdquo;.  </p>

<pre><code class="r">fakeCorrel &lt;- function(nPer=40, nTries=10000) {

    vecP &lt;- rep(-9.9999, nTries)

    for (intCtr in 1:nTries) {
        fakeX &lt;- rnorm(nPer)
        fakeY &lt;- rnorm(nPer)
        vecP[intCtr] &lt;- cor.test(fakeX, fakeY)$p.value

        if (intCtr==1) {
            storeX &lt;- fakeX
            storeY &lt;- fakeY
            storeP &lt;- cor.test(fakeX, fakeY)$p.value
            storeN &lt;- intCtr
        } else {
            if (cor.test(fakeX, fakeY)$p.value &lt; storeP) {
                storeX &lt;- fakeX
                storeY &lt;- fakeY
                storeP &lt;- cor.test(fakeX, fakeY)$p.value
                storeN &lt;- intCtr
            }
        }
    }

    return(list(xVal=storeX, yVal=storeY, minP=storeP, atN=storeN, vecP=vecP))

}

fakeList &lt;- fakeCorrel()
fakeList[1:4]
</code></pre>

<pre><code>## $xVal
##  [1] -1.77698192 -1.65947427  1.42792339  0.21820668  1.26930804
##  [6] -0.60310009 -1.13742923  1.57300624 -0.36329628  1.59995686
## [11] -0.41904749  1.46158678  1.21618988 -0.75772172  0.36365666
## [16] -1.26057220  1.67409451  1.33385455 -0.26732996  1.36747061
## [21]  0.12313666 -0.98927509 -2.16049727  0.31066532  1.39511338
## [26] -0.11951718 -0.74391504 -1.08597715  0.23443222 -0.02276521
## [31]  1.32743615  0.10931297 -1.35512442 -1.67515460  1.04211544
## [36] -1.76028263  1.05793038 -1.51499693 -0.56711115  0.52206420
## 
## $yVal
##  [1]  0.54450995 -1.18677522  1.72682638  0.16335482  2.22695727
##  [6] -0.34356403  1.06491373  0.93898733 -1.43545293  1.25344596
## [11]  0.91936212 -1.25752829  0.13501065 -0.78393059  0.61068363
## [16] -0.05245019  1.50064076  1.06389177  0.07836032  0.58587629
## [21] -0.75509164 -0.53127394  0.71066924  0.75418093  0.96860596
## [26]  0.30130494 -1.93149556  0.19783818  0.73953251 -0.35114015
## [31]  0.83531354 -0.24259721 -0.86837900 -0.32524884  1.84189445
## [36] -1.79588556  1.12050420 -1.35316783  0.18326399  0.20049826
## 
## $minP
## [1] 0.0001569684
## 
## $atN
## [1] 1208
</code></pre>

<pre><code class="r">cor.test(fakeList[[1]],fakeList[[2]])
</code></pre>

<pre><code>## 
##  Pearson&#39;s product-moment correlation
## 
## data:  fakeList[[1]] and fakeList[[2]]
## t = 4.1965, df = 38, p-value = 0.000157
## alternative hypothesis: true correlation is not equal to 0
## 95 percent confidence interval:
##  0.3046307 0.7438521
## sample estimates:
##       cor 
## 0.5627388
</code></pre>

<pre><code class="r">plot(fakeList[[2]],fakeList[[1]],xlab=&quot;Random 1&quot;,ylab=&quot;Random 2&quot;,
     main=paste0(&quot;Random data generated at trial &quot;,fakeList[[4]])
     )
fakeLM &lt;- lm(fakeList[[2]] ~ fakeList[[1]])
summary(fakeLM)
</code></pre>

<pre><code>## 
## Call:
## lm(formula = fakeList[[2]] ~ fakeList[[1]])
## 
## Residuals:
##      Min       1Q   Median       3Q      Max 
## -2.16491 -0.50076  0.05439  0.41548  1.57172 
## 
## Coefficients:
##               Estimate Std. Error t value Pr(&gt;|t|)    
## (Intercept)     0.1938     0.1341   1.445 0.156707    
## fakeList[[1]]   0.4882     0.1163   4.196 0.000157 ***
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Residual standard error: 0.8482 on 38 degrees of freedom
## Multiple R-squared:  0.3167, Adjusted R-squared:  0.2987 
## F-statistic: 17.61 on 1 and 38 DF,  p-value: 0.000157
</code></pre>

<pre><code class="r">abline(a=coef(fakeLM)[[1]], b=coef(fakeLM)[[2]],col=&quot;blue&quot;,lwd=1.5)
title(sub=paste0(&quot;R-squared: &quot;, round(summary(fakeLM)$r.squared, 3),&quot; with Slope: &quot;,
                 round(coef(fakeLM)[[2]],2),&quot; and Intercept: &quot;,round(coef(fakeLM)[[1]],2)
                 )
      )
</code></pre>

<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAfgAAAH4CAMAAACR9g9NAAAApVBMVEUAAAAAADoAAGYAAP8AOjoAOmYAOpAAZmYAZpAAZrY6AAA6ADo6AGY6Ojo6OmY6OpA6ZrY6kJA6kLY6kNtmAABmADpmAGZmOgBmZgBmZjpmkJBmtrZmtv+QOgCQOjqQZgCQkDqQkGaQtpCQ27aQ29uQ2/+2ZgC2Zjq2tma225C2/7a2///bkDrb25Db/7bb/9vb////tmb/25D/29v//7b//9v///9d/q0OAAAACXBIWXMAAAsSAAALEgHS3X78AAASSklEQVR4nO2dC3vjOBWG3XYpm87AsqTT5ZIOLNDATgM0JfH//2no5lvipL5I1pG+731mpmlsHdl+LR1ZTjxFSSApYm8AiQPFg0LxoFA8KBQPCsWDQvGgUDwoFA8KxYNC8aBQPCgUDwrFg0LxoFA8KBQPCsWDQvGgUDwoFA8KxYNC8aBQPCgUD4oo8YfHQnP7enH5/dtHEdprbDezN+ksxPk21KvULw6PzS60Xr8/rMxqdg+Pz0WxKu1OX9zjcEgUX1zSO1L8tpgt/jzE2TbUq/RX14jfWtFbd26bnyu3zx/tl3+EidcHyfy7V0fj5kU1i9t/NQ3kz+ag79SidanW+P5ZLVG/ueNdr2HL6l/VgXWBqjVuv9UxNmUrfPPOzR/V+p0Q1bLWNpRltxa7rFjZ4n9v7UElXi3/jV7x8GgKbd4fbl/1sveH+zf93tLHWqj4qh2Yw6mPrHuhDvrWvbMvKuoja9dwZf9rTLQblFnju4c6xrqsw3ffuf9PO8Tp2jZYp5ayEW+LN3tQi/+qzqaV7u91/Tf2F/XTil++rxcmvqhElPYEUAdyrRTfv+kGolqefmGakT5yurkUm6q51GtUZeu+tzqurRhqLdXa2+Gbd1Zl2QlRL+vUcFaLeWGLVxXaU7iWuq9C6xr3utfSRXR3Mj8njUai+E31WnswmvVxWpXNC3W0NnuTIN0qpTusNgO78ZJV0gyeWjEMus+tw7ffKTsh6mWtGk5WMVjxunjVc+nlPeL3OgXU4re2O1kaYeJNF7nWjdP24bqhXRWvs8GJ+Kqsa65NMugTX4fviO+E6BffWcXQFV8tPxe/M2OOqqvfmzzGHP+qj6ju/9amZ67N9HX1XfH1GlVZ15G6X8rTrl7TCl+/o6N1QtTLOl19ZxVDV3y1/Ez8zp6G1TIrfvm+Xp54c2T2xUmL7xvcdcXXa1RlzfVT/Ut5PrjTZV341ju2ObZCtJa1BnfdVTRbO6p34qvlp+LrdNa5nIMf3LkLN3Ow16o/b8zoo/5j93KuK75Zw5XVfcf9W/WLjV9dzm2twCZ8846J1glRLWttw9kqpen81SC/zvFu+al4lzg2nMBZmH2EyRKJIIl3vezyI2iJIIm33ewq9lbIAEo8aaB4UCgeFIoHheJBoXhQKB4UigeF4kGheFAoHhSKB4XiQaF4UCgeFIoHheJBoXhQKB4UigdljviCSCag+BllSWgoHhSKB4XiQaF4UCgeFIoHheJBoXhQKB4Uik+BD2dYJ4SctThYWdKmKP0fTYpPAIoHheJRYY4nvqB4UCheFAH69Es1zVocrCwoIUZxV6qavjhY2Yy51qgpPl+uuqX4fLnuljk+WxZs1Feh+KVZrlFfheJBoXhQKB4UigeF4kFJRLyQoXBGpCFeysVvRlA8KBSfLPPSXxrimePPmdkYEhFPzqD49PDSf1F8cngasUDk+KwQMVSleM8MaIcUnyGDpEq4RqF4v4hozQO4u7u+nOJHckl8fyOP1fSVdrZ4z1wwXPYdj0jdg2ntFL8IgsS7Tp7iF0GM+Dq3U/wyyMjxrSEdxePQGclTPAjFyQUcxWOgtXeEUDwCd3dn40iKz567qrVT/AQkTK9PokrtpztA8YNIZQr+lMtT8hQ/iDTFX7sTQ/GDSFH89RtwFD+M5HL8zPuuFJ8mH2mn+Cz5WDvFZ8gQ7RSfHcO0U3xe3A3VTvE5Mdx6SfH5MEo7xefCSO0UnwejtVN8DkzQTvECmDkbPEk7xcdn3v0f++WICacOxcdmjnjb2idFoPjYTBdff7hmSgSKj860HN+apKN4HLojOuZ4ECYO5DvMFX94LCy3r3WZivlbR3rwod1Diz8+ryeXJePxo91HV3/48jK5LBmJL+3M8UnhTzvFJ4RP7RSfDH61U3wajPhI1VAoXj7+rZcUL58g2ileOoG0U7xsgmmneMkE1E7xcgmqneKlElg7xcskuHaKl8gC2ileHAEm6XqheFEsZL2keFEsp53iBbGkdooXw7LaKV4IS2uneBEsr53iBRBDO8VHJ452io9MLO0UH5OlJul6ofhYxLReUnwsImun+DhE107xMRCgneKXR4R2il8aIdopflnEaKf4JRGkneKXQ5R2il+IqJN0vVD8AoizXlL8AkjUTvHBkamd4gMjVTvFj2PkUxvlaqf4URTlmL2SrJ3iRzFGvGztFD+K4eKla6f4cQzM8fK1U7x/5E3S9ULxfknDeknxfklGO8X7JCHtFO+PpLRTvC8S007xfkhOO8X7IEHtFD+fJLVT/Fz6tCfxP69R/Az6J+nG3cOLBcVP5lIfT/Ezysrncmqn+BllpXN1RMccnytjBvJSzwKKH82o6zex/T7Fj2TkZTvF58Ho2RqKz4Epk3TM8amTyEeqhkLxw5hqXWqDp/hBTG7sYlM8xQ/Aap/Udik+XVxrn6aQ4lOl7uQnKmSOT5JWbpfbdqdB8ZfpDunEtt1pUPwl8rpsP4Pi+8lcO8X3ktkkXS95ip+VjwGsl5mKnzMCx9BO8Xb9uoNA0U7xndVxtGcqfmSOd+KRtOcqfhxGPJZ2ijcUcNop3oCnfZj494fi5qUsD0+vPkOLAVH7IPHH5436u85TPMIkXS8DxFvh21WG4lGtl4NbvGL33ec+8SoPaG7Pl4kXD6x9WI4/PK71j12P3OqsKPf3byNDxwZa+/xRfdX/t/JAUTFz04ICrn2++DRbvNEu/NQMzOzr+MNjcjnefVy6FLyJ4cGbwKk6eYofsHh/qVXPCB2HJrdT/MeLD19e/IeOQWdIxxz/4eKxUzeDQi8O7CRdL8O6+t3af+iFofUuA8WnnuOp/RSIHO9fe/rjA4AcH6C1Z3BFkH2OD9LJo4i/PDs3I/QiBMrtKOKDhF6AcEM6kBwfJHRwOJK/xjDxx2d1ip/ff5sVOjDUfp1B4vUn7tQIb6T5iOI5SfchIy7nkvnMHa0PIL8WT+2DyC3HU/tA8hrVU/tgchJP7SMY8oWKR/epWdkzd6G0pz9X08uwFr81g7uV19B+CdbaM5id7SWPy7mAnTy0eOGXc0FzO7R4ezk3sqdf6HAFn6SDzvEhQnuBA/mpJC2e2qeT8BcqqH0OAz+Bs/EfeibUPg+hH7b8aERF7XMZMYHjOfRHRa8Up/b5yPyw5VXx1O4DmaP6K+Kp3Q8yxV/M8dTui5S+O5fDJ+nEzAMO/e7cfhX77lwG1iXN/A+9nLN/fIYeRxbakxN//Pqi/rz3PuBwcugxZKI9OfGlcr4vipEX8952MBvtZWo5PkjooeSkXRBjxP8vwgcxqD0QQ8S/P+gruePz8pdz1B6MAeL1B692q/3yX6ig9oAM+Xi1uow7PBaj78zOE5/DbI1khoqf8PijOeJpPTRDxU+4Iz9dPLWHR6B4al8CcV+hEqxdzOSLD4RN4AjWLmi61QeixEvWTvG+Qp8hWzvF+wp9QgTtY3M2c7yX0B1itPa8WvBYJIiPNElH8dMX+ygbLbVT/PTF88vGHNFllbPHEle89IF8xsQUT+0RiSee2qMSSzy1RyaOeGqPTgzx1C6A5cVTuwgWE28vmvlJOiksJd5Mky1jHXpeZjALil+osWPPxA5mMfFK+zI6KH4QC4m/u1usA6b4QSwiftkRHXP8EBYQz4G8RIKLp3aZBBZP7VIJKp7a5RJQPLVLJvZHr0gkKB4UigeF4kGheFAoHhSKB4XiQaF4UCgeFIoHBUc8P5/RYa74K89Ck3Wc+YmsLrNbvP2/5aeVXRKK7zK/qz97zG1RMX2rAkDxXZjjQcERTzr4Eb/ry/MULxmKB4XiQWGOH0NGA0SKH0FOl4QUPwKK9xE6QSjeR+gUYY73EJpEPZEoPiIxUwfFR4TiQaF4VJjjydJQPCgUDwrFg0LxoFA8KBTfR0Zz8peg+B5yugt3CYrvgeIpPlsovg/meFDxAFA8KBQPSkbiARKzR/IRjzAU9wjFg0LxoOQjnjl+FBmJJ2OgeFAoHhSKB4XiQaF4UCgeFIoHheJBkS2ek3HBEC2e0+/hoHhQKB4U0eKZ48MhWzwJBsWDQvGgUDwoFA8KxYNC8aBQPChpieeEjjeSEs8pXH9Ai0fuQJDFQ3cgSYn33EQpfvLiYGUXgeInLw5WdhmY46cuDlaWhIbiQYkiHrmLlUIM8dCDKilQvE8S6soo3iMp7RhzvEcofnbZNKH42WUTJaGujOJBoXhQKB4UigeF4kGheFAoHhSKB4XiQaF4UCgeFIoHheJBmS3+/aG4eSnLw9Pr+LIkHnPFH5836u+a4lNjrngrfLui+MTw0eIVu+8+U3xSzM7xh8e1/rG7rcUXFTM3jYSEo3pQKB4UP+J36+llSRQoHhSKB4U5HhSKB4XiQaF4UCgeFIoHheIDIvl+BcWHQ/TX5Sk+HBQPCsWjwhxPxEHxoFA8KBQPCsWDQvGgUDwoFA8KxYNC8aBQPCghxRPJhBPvN0hmsaVvOMWnGJzi5caWvuEUn2JwipcbW/qGU3yKwSlebmzpG85JGFAoHhSKB4XiQaF4UCgeFIoHheJBoXhQKB4UH+LfH4pi4yHOhejnz0v3wuGxuH8LEtkQarN9HW4P4g9fXsr3Ty/zA/WyL26DHEH9HP7dKkRkQ6jN9na4PYjf68O3DdTktzd/C9N09P+4Ea5VBttsb4fbU47Xp2EgAtl5/+Et5FYHPKlKL4fbj3j9vxWFItAR3N+nK97H4Z4pflsUq/p/L/GMjc0Wf4aXw+1nVB9uTB/sCIbN8WFH9T4OtwfxYb2HOoK6uww4qg8n3tPh9iB+Z763EUw+r+O7eDrcnLkDheJBoXhQKB4UigeF4kGheFAoHhSKB4XiQaF4UCgeFIoHheJBoXhQKB4UigeF4kGheFAoHhQs8fr7hkX/t9r0d+kulQr5pZhYgIk3Cnd9n669LD7c9x9jgihe/2u/a/z+w1/MJ5UPj8WvftroH8rx8evPRbHeq7+mTMDvP8YEUbxq8ea7xp9f3x/W5kt0W/VDnQBb89vxeaXOi1XTw7OrTx6b411Pf3h6NW3/86v+OpXq6vUPdUYcv76U+m/9zTqKTx6tcH9jfG71IM+JN2a3G/1DGaf4/DAKdyqPHx43lXG2eACMQpPDtfFPL078SY6n+Oxwo3o1pNsVehxfiT8+d0b1FE+yheJBoXhQKB4Uigclnvgrd8qu0txNaR5msq8C6QF4z7NC7CV7a3SuiuoSH4zX209LMdWqbb60wXazmoAfXwo0a7TrMe9eqccXEcVfvlN2lVp881BSo1u/qm+k7c/CdsTr+Rtd9XU7naee7oqNKXZpg2eIb9dj9uBaPb6ILb7ae9dm1bn//dd6XsXdQvvtT7ev9hLb3UazhboPLDPzMNWNNHsJrg+ofurr/v7fn7+p8r98/oPrCUwxtZL+aSMfnv5a6Llc+9t5BWojNu1n4/Xe3bOnl3nPxHHB3Par8O26DmaLTuqxexD6GXya2OLdia33XZ305hlkN5X4+haaOqRb+3AyN8VmA3QOT9P261/K3do01N3adfXuXpw+JWy11azd/dvh8f5tf/ta1XNawfHrP57b4vvv7pWt91zo3co8n0yfg+pN+4arq7n7196R9/zFd+6U2d10s+VViy/rW2h6uXrpJtVtgPZDSd8f7K0X11Srd394++fPq6PpQpqZeVu40C3QzdOr9XXvqlZ09ZxVsFvrak0XfFMJObu7V9YJxf5wwZpqq72wddXiO09XtZ1Qu54wxG3x5k6ZeXSpOg20CHWqH5uuvrmFpgdjhe0K6ic3d9uFfWUP5r6+8frt6ZfP355ez8XrdT+5E6IyriK7ek4rUK+qwd3vv9qlPXf3ylPxzUbrUGW1F66uyy2+XU8oInf1u9bgVXe4nRbfuoXmWmGnxZ88lHTbDK621bNet3/63fHrz6vyVLx59Lc99lWL/2Im6OvW3q3AXiisqzfL/rt75an4p/pKoxk0lPYcbbf4zo5ULzpbEoDI4vWdMo1uoy5Z7myT2Ln29Mk185NkWrYfStr0lTZo3Vj2hc3yp+LNqN6dYVWOX9UVVOPpzlNPTVevt6seS5zf3TsR74LZu0BmIzp1tUb17YGFS2whH7eqiT2400MhzbYe1f9a73VR/Pj02rqFVtpRsbuNVuV/c/n7bi/dWzm+6f/NmN6O0o/PZgzdFHU5vhppf/ljNap373cqcJdr+3pQ0nt3ry1e1ffaClaP6vW/ti63RSf1mH+beoIhb+Yu9HA2fq1x9vAEil++Voon8aB4UP4PNkeNQ6z+eecAAAAASUVORK5CYII=" alt="plot of chunk unnamed-chunk-27"/></p>

<pre><code class="r">plot(x=fakeList$vecP[order(fakeList$vecP)], ylab=&quot;P-value&quot;, xlab=&quot;N-th Lowest P-value&quot;,
     main=paste0(&quot;P-values for &quot;,length(fakeList$vecP),&quot; random correlations&quot;)
     )
</code></pre>

<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-27"/></p>

<pre><code class="r">plot(x=log10(fakeList$vecP[order(fakeList$vecP)]), ylab=&quot;Log10(P-value)&quot;, 
     xlab=&quot;N-th Lowest P-value&quot;, type=&quot;l&quot;, col=&quot;blue&quot;, lwd=2,
     ylim=c(floor(log10(0.05/length(fakeList$vecP))), 0),
     main=paste0(&quot;P-values for &quot;,length(fakeList$vecP),&quot; random correlations&quot;)
     )

abline(h=log10(0.05/length(fakeList$vecP)), lty=2, col=&quot;red&quot;)
lines(x=log10(0.05*(1:length(fakeList$vecP))/length(fakeList$vecP)), 
      lty=2, col=&quot;dark green&quot;
      )
ctBon &lt;- sum(fakeList$vecP &lt;= 0.05/length(fakeList$vecP))
ctFDR &lt;- sum(fakeList$vecP[order(fakeList$vecP)] &lt;= 
             0.05 * (1:length(fakeList$vecP) / length(fakeList$vecP))
             )
legend(&quot;right&quot;, legend=c(&quot;Log10 of P&quot;, paste0(&quot;FDR (&quot;,ctFDR,&quot;)&quot;), paste0(&quot;Bonferroni (&quot;,ctBon,&quot;)&quot;)), 
       lty=c(1,2,2), lwd=c(2,1,1), col=c(&quot;blue&quot;,&quot;dark green&quot;,&quot;red&quot;)
       )
</code></pre>

<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-27"/></p>

<p>####<em>7.03 Chebyshev Inequality</em><br/>
The Chebyshev inequality states that there can never be more than 1/k<sup>2</sup> of the distribution that lies further than k-sigma from the mean.  The inequality is powerful in that it need not make any assumptions about distribution, but weak in that you can make a much more precise interval claim if you know the distribution.  The below code provides an example of how this works:  </p>

<pre><code class="r">## Create a dummy distribution with problems
## 80% from rnorm(mean=1,sd=0.1), 15% from 0.1*rpois(lambda=10), 5% from 1000*rbinom(prob=0.05)

dat1 &lt;- rnorm(8000, mean=1, sd=0.1) ## mean 1
dat2 &lt;- rpois(1500, lambda=10) ## mean 10
dat3 &lt;- 1000 * rep(0:1, c(450,50)) ## mean 100
datAll &lt;- c(dat1, dat2, dat3)

nAll &lt;- length(datAll)
meanAll &lt;- mean(datAll)
sdAll &lt;- sd(datAll)
print(paste0(&quot;Mean: &quot;, round(meanAll,2), &quot; with SD: &quot;, round(sdAll, 2)) )
</code></pre>

<pre><code>## [1] &quot;Mean: 7.3 with SD: 70.46&quot;
</code></pre>

<pre><code class="r">## Graph by abs(0.1 + SD away from mean)
orderSD &lt;- log10(0.1 + abs((datAll - meanAll)/sdAll))

plot(x=orderSD[order(orderSD)], type=&quot;l&quot;, col=&quot;blue&quot;, 
     ylab=&quot;Log10 of (0.1 + abs(#SD from Mean))&quot;, main=&quot;Sorted Data&quot;
     )
</code></pre>

<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-28"/></p>

<pre><code class="r">## Number 1/2/3/5/10/14/15/16 SD from mean
resFrame &lt;- NULL

for (sdAway in c(1, 2, 3, 5, 10, 14, 15, 16)) {
    actData &lt;- sum(abs((datAll-meanAll)/sdAll) &gt;= sdAway)
    gaussData &lt;- 2 * (1 - pnorm(sdAway)) * nAll
    chebyData &lt;- (1/sdAway^2) * nAll
    resFrame &lt;- rbind(resFrame, data.frame(sdAway=sdAway, actData=actData, 
                                           gaussData=round(gaussData,0), 
                                           chebyData=round(chebyData,0)
                                           )
                     )
}

## Print actual vs. theoretical
resFrame
</code></pre>

<pre><code>##   sdAway actData gaussData chebyData
## 1      1      50      3173     10000
## 2      2      50       455      2500
## 3      3      50        27      1111
## 4      5      50         0       400
## 5     10      50         0       100
## 6     14      50         0        51
## 7     15       0         0        44
## 8     16       0         0        39
</code></pre>

<pre><code class="r">minSD &lt;- (min(datAll)-meanAll)/sdAll
maxSD &lt;- (max(datAll)-meanAll)/sdAll

print(paste0(&quot;Min/Max SD from mean are: &quot;, round(minSD,3), &quot; to &quot;, round(maxSD, 3)) )
</code></pre>

<pre><code>## [1] &quot;Min/Max SD from mean are: -0.104 to 14.089&quot;
</code></pre>

<p>With the highly skewed distribution, the Gaussian rule for standard deviations fails terribly.  Still, the Chebyshev inequality is spot on, with the actual data no longer being n SD from the mean once the relevant 1/n<sup>2</sup> is no longer sufficiently large to allow it.  </p>

<p>Further, note that this data is all positive skew.  The most negative data are only -0.1 SD from the mean, showing again what a debacle could be created by assuming the normal +/- &frac12;/3 standard deviation rules.  </p>

<p>####<em>7.04 Paired data (t-test)</em><br/>
Paired data can often significantly reduce the variance, allowing for detection of events that would be non-significant if looking at two independent groups.  Below is an example of very high variance data that participates in two trials.  The variance of Trial A vs. Trial B is set to be very small.  </p>

<pre><code class="r">## Create Trial A vector with mean 200 and SD 40
trialA &lt;- rnorm(100,mean=200,sd=40)

## Create Trial B vector as Trial A vector plus N(1, 1)
trialB &lt;- trialA + rnorm(100,mean=1,sd=1)

## Plot data and differences
plot(trialA, trialB, main=&quot;Trial A vs. Trial B&quot;)
</code></pre>

<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-29"/></p>

<pre><code class="r">plot(trialB - trialA, main=&quot;Trial B minus Trial A&quot;)
</code></pre>

<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-29"/></p>

<pre><code class="r">## Run various t-tests and see the outcomes
t.test(trialA, trialB)
</code></pre>

<pre><code>## 
##  Welch Two Sample t-test
## 
## data:  trialA and trialB
## t = -0.1646, df = 198, p-value = 0.8694
## alternative hypothesis: true difference in means is not equal to 0
## 95 percent confidence interval:
##  -11.87500  10.04536
## sample estimates:
## mean of x mean of y 
##  199.4752  200.3900
</code></pre>

<pre><code class="r">t.test(trialA, trialB, paired=TRUE)
</code></pre>

<pre><code>## 
##  Paired t-test
## 
## data:  trialA and trialB
## t = -10.683, df = 99, p-value &lt; 2.2e-16
## alternative hypothesis: true difference in means is not equal to 0
## 95 percent confidence interval:
##  -1.0847310 -0.7449028
## sample estimates:
## mean of the differences 
##              -0.9148169
</code></pre>

<pre><code class="r">t.test(trialA-trialB) ## Same as paired
</code></pre>

<pre><code>## 
##  One Sample t-test
## 
## data:  trialA - trialB
## t = -10.683, df = 99, p-value &lt; 2.2e-16
## alternative hypothesis: true mean is not equal to 0
## 95 percent confidence interval:
##  -1.0847310 -0.7449028
## sample estimates:
##  mean of x 
## -0.9148169
</code></pre>

<p>If the t-test is required to assume non-paired data, then the differences are not statistically significant.  This is because the standard error for trial A mean (standalone) will be roughly 40 / sqrt(100) or 4, which swamps the true difference in means of only 1.  </p>

<p>The paired t-test easily picks up the difference since the standard error for trialA - trialB will be roughly 1 / sqrt(100) or 0.1, with a mean of roughly -1.  Note that running the A vs. B paired t-test is identical to running a t-test on (A-B).  It is easier to interpret when using the &ldquo;paired&rdquo; statement.  </p>

<p>####<em>7.05 Paired data (prop-test)</em><br/>
Paired data can also be important for tests of proportions, when the variable of interest is either paired and/or dependent.  An example is included below:  </p>

<pre><code class="r">## Example (paired) - a group of students of varying capability took two tests
## Each of their odds of passing improved by ~10% after a quick online study
studentPreProb &lt;- c(runif(n=400, min=0.1, max=0.2), runif(n=400, min=0.8, max=0.9))
studentPostProb &lt;- studentPreProb + runif(n=800, min=0, max=0.1)
studentPrePass &lt;- rbinom(length(studentPreProb), size=1, prob=studentPreProb)
studentPostPass &lt;- rbinom(length(studentPostProb), size=1, prob=studentPostProb)

## Assume two independent proportions
prop.test(x=c(sum(studentPrePass), sum(studentPostPass)),  
          n=c(length(studentPrePass), length(studentPostPass)), 
          correct=FALSE
          )
</code></pre>

<pre><code>## 
##  2-sample test for equality of proportions without continuity
##  correction
## 
## data:  c(sum(studentPrePass), sum(studentPostPass)) out of c(length(studentPrePass), length(studentPostPass))
## X-squared = 6.5099, df = 1, p-value = 0.01073
## alternative hypothesis: two.sided
## 95 percent confidence interval:
##  -0.11262146 -0.01487854
## sample estimates:
##  prop 1  prop 2 
## 0.48500 0.54875
</code></pre>

<pre><code class="r">## Assume two paired proportions
## Create matrix of Pass/Fail
passBoth &lt;- sum(studentPrePass * studentPostPass)
failBoth &lt;- sum((studentPrePass==0) * (studentPostPass==0))
passPre &lt;- sum((studentPrePass==1) * (studentPostPass==0))
passPost &lt;- sum((studentPrePass==0) * (studentPostPass==1))

pfMatrix &lt;- matrix(data=c(passBoth, passPre, passPost, failBoth), nrow=2, byrow=TRUE, 
                   dimnames=list(c(&quot;Pass Pre&quot;, &quot;Fail Pre&quot;),c(&quot;Pass Post&quot;, &quot;Fail Post&quot;))
                   )
pfMatrix
</code></pre>

<pre><code>##          Pass Post Fail Post
## Pass Pre       319        69
## Fail Pre       120       292
</code></pre>

<pre><code class="r">mcnemar.test(pfMatrix, correct=FALSE)
</code></pre>

<pre><code>## 
##  McNemar&#39;s Chi-squared test
## 
## data:  pfMatrix
## McNemar&#39;s chi-squared = 13.762, df = 1, p-value = 0.0002075
</code></pre>

<p>By looking only at cases of Pass -&gt; Fail vs. Fail -&gt; Pass, the mcnemar.test is able to more precisely tease out the differences in the groups.  The challenge with the proportions test assuming independence is that most students either passed both exams or failed both exams based on their natural talents, which tends to wash out the impact that we hope to study.  </p>

<p>####<em>7.06 Fisher Exact Factorials</em><br/>
The Fisher Exact Test is an odds ratio based on the permutations of non-negative integers in a 2x2 table with fixed marginals.  Essentially, the fixed marginals and non-negative marginals mean there are a finite number of combinations, each with an associated p.  The odds ratio sums all of the p that are equal or more extreme than a specific combination, reporting that back as the overall p-value.  </p>

<pre><code class="r">fishExact &lt;- function(mtxIn) {
    curA &lt;- mtxIn[1,1]
    maxA &lt;- min(colSums(mtxIn)[1],rowSums(mtxIn)[1])
    minA &lt;- max(0, sum(diag(mtxIn) * c(1,-1)) )

    storeData &lt;- matrix(data=NA,nrow=(maxA-minA+1), ncol=2)

    for (intDelta in (minA-curA):(maxA-curA)) {
        mtxWork &lt;- mtxIn + matrix(data=intDelta*c(1,-1,-1,1), nrow=2)

        numer &lt;- prod(factorial(c(colSums(mtxWork), rowSums(mtxWork)) ) )
        denom &lt;- prod(factorial(mtxWork), factorial(sum(mtxWork)) )

        print(paste0(&quot;Using value A=&quot;,curA+intDelta,&quot; gives ratio=&quot;,round(numer/denom,4)))

        storeData[intDelta - minA + curA + 1, 1] &lt;- curA + intDelta
        storeData[intDelta - minA + curA + 1, 2] &lt;- numer/denom
    }

    storeData
}

fishMatrix &lt;- matrix(data=c(8,4,2,5), nrow=2, byrow=TRUE)
fishData &lt;- fishExact(fishMatrix)
</code></pre>

<pre><code>## [1] &quot;Using value A=3 gives ratio=0.0024&quot;
## [1] &quot;Using value A=4 gives ratio=0.0375&quot;
## [1] &quot;Using value A=5 gives ratio=0.18&quot;
## [1] &quot;Using value A=6 gives ratio=0.3501&quot;
## [1] &quot;Using value A=7 gives ratio=0.3001&quot;
## [1] &quot;Using value A=8 gives ratio=0.1125&quot;
## [1] &quot;Using value A=9 gives ratio=0.0167&quot;
## [1] &quot;Using value A=10 gives ratio=7e-04&quot;
</code></pre>

<pre><code class="r">pCurA &lt;- fishData[fishData[,1]==8, 2] ## Current upper right
pTwoSide &lt;- sum(fishData[,2] * (fishData[,2] &lt;= pCurA)) ## Two-sided p
print(paste0(&quot;Sum of probability &lt;= &quot;,round(pCurA,4),&quot; is &quot;,round(pTwoSide,4)))
</code></pre>

<pre><code>## [1] &quot;Sum of probability &lt;= 0.1125 is 0.1698&quot;
</code></pre>

<pre><code class="r">fisher.test(fishMatrix)
</code></pre>

<pre><code>## 
##  Fisher&#39;s Exact Test for Count Data
## 
## data:  fishMatrix
## p-value = 0.1698
## alternative hypothesis: true odds ratio is not equal to 1
## 95 percent confidence interval:
##   0.4748063 69.1739992
## sample estimates:
## odds ratio 
##   4.556516
</code></pre>

<pre><code class="r">barplot(height=fishData[,2], names.arg=fishData[,1], col=&quot;light blue&quot;, 
        main=&quot;Probabilities by Upper-Left Value&quot;, xlab=&quot;x[1,1]&quot;, ylab=&quot;Probability&quot;
        )
</code></pre>

<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-31"/></p>

<p>The results of the hand calculation match the fisher.test outcome, and the bar plot shows how much the relative probabilities of a configuration can change as the upper-left value changes.  </p>

<p>####<em>7.07 Vector Factorial and Correlation</em><br/>
The correlation will change significantly if the vectors are reordered.  Below is an example of the degree to which various correlations are observed between two identical vectors, one randomized post-hoc.  </p>

<pre><code class="r">par(mfrow=c(1,2))

## Run for vectors of length 10
vecA &lt;- 1:10
pStore &lt;- matrix(data=rep(-9, 8000),nrow=4000)

for (intCtr in 1:nrow(pStore)) {
    vecB &lt;- sample(vecA, length(vecA), replace=FALSE)
    pStore[intCtr, 1] &lt;- cor.test(vecA, vecB)$estimate
    pStore[intCtr, 2] &lt;- cor.test(vecA, vecB)$p.value
}

summary(pStore[,1])
</code></pre>

<pre><code>##      Min.   1st Qu.    Median      Mean   3rd Qu.      Max. 
## -0.903000 -0.236400 -0.006061 -0.003800  0.236400  0.915200
</code></pre>

<pre><code class="r">hist(pStore[,1], col=&quot;light blue&quot;, breaks=seq(-1,1,by=0.05), xlab=&quot;Correlation&quot;,
     main=&quot;Correlations for Randomized Integer 1:10&quot;, cex.main=0.9
     )
hist(pStore[,2], col=&quot;dark green&quot;, breaks=seq(0,1,by=0.05), xlab=&quot;P-value&quot;,
     main=&quot;P-Values for Correlations on 1:10&quot;, cex.main=0.9
     )
</code></pre>

<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-32"/></p>

<pre><code class="r">## Run for vectors of length 100
vecA &lt;- 1:100
pStore &lt;- matrix(data=rep(-9, 8000),nrow=4000)

for (intCtr in 1:nrow(pStore)) {
    vecB &lt;- sample(vecA, length(vecA), replace=FALSE)
    pStore[intCtr, 1] &lt;- cor.test(vecA, vecB)$estimate
    pStore[intCtr, 2] &lt;- cor.test(vecA, vecB)$p.value
}

summary(pStore[,1])
</code></pre>

<pre><code>##      Min.   1st Qu.    Median      Mean   3rd Qu.      Max. 
## -0.303800 -0.066400  0.002574  0.002302  0.070700  0.368900
</code></pre>

<pre><code class="r">hist(pStore[,1], col=&quot;light blue&quot;, breaks=seq(-1,1,by=0.05), xlab=&quot;Correlation&quot;,
     main=&quot;Correlations for Randomized Integer 1:100&quot;, cex.main=0.9
     )
hist(pStore[,2], col=&quot;dark green&quot;, breaks=seq(0,1,by=0.05), xlab=&quot;P-value&quot;,
     main=&quot;P-Values for Correlations on 1:100&quot;, cex.main=0.9
     )
</code></pre>

<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-32"/></p>

<pre><code class="r">## Run for vectors of length 1000
vecA &lt;- 1:1000
pStore &lt;- matrix(data=rep(-9, 8000),nrow=4000)

for (intCtr in 1:nrow(pStore)) {
    vecB &lt;- sample(vecA, length(vecA), replace=FALSE)
    pStore[intCtr, 1] &lt;- cor.test(vecA, vecB)$estimate
    pStore[intCtr, 2] &lt;- cor.test(vecA, vecB)$p.value
}

summary(pStore[,1])
</code></pre>

<pre><code>##      Min.   1st Qu.    Median      Mean   3rd Qu.      Max. 
## -0.133100 -0.019900  0.001465  0.001408  0.023220  0.115500
</code></pre>

<pre><code class="r">hist(pStore[,1], col=&quot;light blue&quot;, breaks=seq(-1,1,by=0.05), xlab=&quot;Correlation&quot;,
     main=&quot;Correlations for Randomized Integer 1:1000&quot;, cex.main=0.9
     )
hist(pStore[,2], col=&quot;dark green&quot;, breaks=seq(0,1,by=0.05), xlab=&quot;P-value&quot;,
     main=&quot;P-Values for Correlations on 1:1000&quot;, cex.main=0.9
     )
</code></pre>

<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-32"/></p>

<pre><code class="r">par(mfrow=c(1,1))
</code></pre>

<p>Consistent with CLT, the distribution of the randomized correlations becomes much more compact as n-per-trial increases.  For each value of n-per-trial, the p-values are distributed as runif(min=0, max=1), consistent with the p-values that should be observed for multiple trials drawn from a true null hypothesis distribution.<br/>
####<em>7.08 Impact of Each Pair in Vector Correlation</em><br/>
Suppose that you have a air of vectors with correlation r.  In many cases, different paired points will have a different impact on the reported correlation.  Below is an experiment to see the contribution of each of the pairs.  </p>

<pre><code class="r">vecA &lt;- 1:40
vecB &lt;- sample(1:40, 40, replace=FALSE)

## Automated correlation
pCor &lt;- cor(vecA, vecB)
pCor
</code></pre>

<pre><code>## [1] -0.07842402
</code></pre>

<pre><code class="r">## Hand-calculated correlation
stdA &lt;- (vecA - mean(vecA)) / sd(vecA)
stdB &lt;- (vecB - mean(vecB)) / sd(vecB)
scoreN &lt;- (stdA * stdB) / (length(stdA) - 1)
sum(scoreN)
</code></pre>

<pre><code>## [1] -0.07842402
</code></pre>

<pre><code class="r">## Plot the individual contributions
sortScore &lt;- scoreN[order(-scoreN)]
plot(x=1:length(sortScore), y=sortScore, ylab=&quot;Contribution&quot;, pch=20, col=&quot;light blue&quot;,
     main=paste0(&quot;Pair Contribution to Overall Correlation&quot;),
     cex.axis=0.8, cex=4, ylim=c(-.1,.1)
     )

## Now change the top 4 points to each be the respective vector means
modA &lt;- vecA
modB &lt;- vecB

chgKeys &lt;- which(scoreN &gt;= sortScore[4])
modA[chgKeys] &lt;- mean(vecA)
modB[chgKeys] &lt;- mean(vecB)
cor(modA, modB)
</code></pre>

<pre><code>## [1] -0.3087338
</code></pre>

<pre><code class="r">## And layer the new leverage points on top of the existing graph
newStdA &lt;- (modA - mean(modA)) / sd(modA)
newStdB &lt;- (modB - mean(modB)) / sd(modB)
newScoreN &lt;- (newStdA * newStdB) / (length(newStdA) - 1)
sum(newScoreN)
</code></pre>

<pre><code>## [1] -0.3087338
</code></pre>

<pre><code class="r">newPCor &lt;- cor(newStdA, newStdB)
newPCor
</code></pre>

<pre><code>## [1] -0.3087338
</code></pre>

<pre><code class="r">points(x=1:length(newScoreN), y=newScoreN[order(-scoreN)], col=&quot;orange&quot;, pch=20, cex=3)

legend(&quot;top&quot;, legend=c(paste0(&quot;Original: &quot;, round(pCor,3)), 
                       paste0(&quot;Modified: &quot;, round(newPCor,3)) 
                       ),
       pch=20, col=c(&quot;light blue&quot;, &quot;orange&quot;), pt.cex=c(4,3)
       )
</code></pre>

<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-33"/></p>

<p>Moving just 10% of the points to the mean drives the correlation significantly more negative.  </p>

<p>####<em>7.09 Post-hoc group comparisons (ANOVA)</em><br/>
ANOVA is often run to determine if one or more group means are different.  This is frequently followed by individual comparisons of group means, with some risk of Type I error if many groups are compared.  One school holds that for three-group ANOVA, there is no need for alpha-correction in the post-hoc tests.  Let&#39;s see what happens in a few key cases:  </p>

<pre><code class="r">## All three groups drawn from the same population
## Run 2000 trials for 100 randoms for each of 3 groups
nTrials &lt;- 2000
nPer &lt;- 100
aovP &lt;- rep(-9, nTrials)
aovCI &lt;- matrix(data=rep(-9, nTrials*3), nrow=nTrials)

for (intCtr in 1:2000) {
    vecA &lt;- rnorm(nPer, mean=0, sd=1)
    vecB &lt;- rnorm(nPer, mean=0, sd=1)
    vecC &lt;- rnorm(nPer, mean=0, sd=1)

    testFrame &lt;- data.frame(value=c(vecA, vecB, vecC), 
                            group=rep(c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;), c(nPer, nPer, nPer) )
                            )

    aovRes &lt;- aov(value ~ group, data=testFrame)
    aovP[intCtr] &lt;- summary(aovRes)[[1]][1,5]  ## Better way to get p-value?

    critT &lt;- qt(0.975, df=aovRes$df.residual)
    keyRSS &lt;- sqrt(sum(aovRes$residual^2) / aovRes$df.residual)
    keyCI &lt;- critT * keyRSS * sqrt(1/nPer + 1/nPer) ## Fisher LSD

    aovCI[intCtr, 1] &lt;- abs(mean(vecA) - mean(vecB)) &gt; keyCI
    aovCI[intCtr, 2] &lt;- abs(mean(vecA) - mean(vecC)) &gt; keyCI
    aovCI[intCtr, 3] &lt;- abs(mean(vecB) - mean(vecC)) &gt; keyCI

}

hist(aovP, col=&quot;light blue&quot;, xlab=&quot;ANOVA p-value&quot;, 
     main=&quot;ANOVA P-Values - 3-Group Random (Same Mean)&quot;
     )
</code></pre>

<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-34"/></p>

<pre><code class="r">print(paste0(&quot;During &quot;,nTrials,&quot; trials, &quot;,sum(aovP&lt;0.05),&quot; have p &lt; 0.05&quot;))
</code></pre>

<pre><code>## [1] &quot;During 2000 trials, 118 have p &lt; 0.05&quot;
</code></pre>

<pre><code class="r">print(paste(&quot;Significant pairwise comparisons:&quot;, sum(aovCI[,1] &amp; aovP&lt;0.05), 
            sum(aovCI[,2] &amp; aovP&lt;0.05), sum(aovCI[,3] &amp; aovP&lt;0.05)
           )
      )
</code></pre>

<pre><code>## [1] &quot;Significant pairwise comparisons: 62 59 59&quot;
</code></pre>

<pre><code class="r">## One group drawn from different population
## Run 2000 trials for 100 randoms for each of 3 groups
nTrials &lt;- 2000
nPer &lt;- 100
aovP &lt;- rep(-9, nTrials)
aovCI &lt;- matrix(data=rep(-9, nTrials*3), nrow=nTrials)

for (intCtr in 1:2000) {
    vecA &lt;- rnorm(nPer, mean=0, sd=1)
    vecB &lt;- rnorm(nPer, mean=0, sd=1)
    vecC &lt;- rnorm(nPer, mean=1, sd=1)

    testFrame &lt;- data.frame(value=c(vecA, vecB, vecC), 
                            group=rep(c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;), c(nPer, nPer, nPer) )
                            )

    aovRes &lt;- aov(value ~ group, data=testFrame)
    aovP[intCtr] &lt;- summary(aovRes)[[1]][1,5]  ## Better way to get p-value?

    critT &lt;- qt(0.975, df=aovRes$df.residual)
    keyRSS &lt;- sqrt(sum(aovRes$residual^2) / aovRes$df.residual)
    keyCI &lt;- critT * keyRSS * sqrt(1/nPer + 1/nPer) ## Fisher LSD

    aovCI[intCtr, 1] &lt;- abs(mean(vecA) - mean(vecB)) &gt; keyCI
    aovCI[intCtr, 2] &lt;- abs(mean(vecA) - mean(vecC)) &gt; keyCI
    aovCI[intCtr, 3] &lt;- abs(mean(vecB) - mean(vecC)) &gt; keyCI

}

hist(aovP, col=&quot;light blue&quot;, xlab=&quot;ANOVA p-value&quot;, 
     main=&quot;ANOVA P-Values - 3-Group Random (One Mean Different)&quot;
     )
</code></pre>

<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-34"/></p>

<pre><code class="r">print(paste0(&quot;During &quot;,nTrials,&quot; trials, &quot;,sum(aovP&lt;0.05),&quot; have p &lt; 0.05&quot;))
</code></pre>

<pre><code>## [1] &quot;During 2000 trials, 2000 have p &lt; 0.05&quot;
</code></pre>

<pre><code class="r">print(paste(&quot;Significant pairwise comparisons:&quot;, sum(aovCI[,1] &amp; aovP&lt;0.05), 
            sum(aovCI[,2] &amp; aovP&lt;0.05), sum(aovCI[,3] &amp; aovP&lt;0.05)
           )
      )
</code></pre>

<pre><code>## [1] &quot;Significant pairwise comparisons: 89 2000 2000&quot;
</code></pre>

<p>When the true population means are the same, the ANOVA comes back significant ~5% of the time with each of the pairwise comparisons being significant about 3% of the time (note that the pairwise comparisons are only counted as significant if the ANOVA came back significant).</p>

<p>When the true population means have one different element, the ANOVA comes back significant 100% of the time, with the pairwise comparison of the items from the identical population showing significant difference only ~5% of the time.  </p>

</body>

</html>
